//////////////////////////////////////////////////////////////////////////////
// FileName 	: Zone.cpp
// WrittenBy	:
// Description	:
//////////////////////////////////////////////////////////////////////////////

#include "Zone.h"

#include <stdio.h>
#include <string.h>
#include "Assert.h"
#include "LogClient.h"

#include "ZoneGroup.h"
#include "ZoneInfo.h"
#include "ZoneInfoManager.h"
#include "PCManager.h"
#include "NPCManager.h"
#include "MonsterManager.h"

#include "EventMonsterManager.h"

#include "CombatMonsterManager.h"

#include "EffectManager.h"
#include "EffectSchedule.h"
#include "NPCInfo.h"
#include "WeatherManager.h"
#include "Creature.h"
#include "Item.h"
#include "ItemInfo.h"
#include "DarkLightInfo.h"
#include "DB.h"
#include "Slayer.h"
#include "Vampire.h"
#include "Monster.h"
#include "NPC.h"
#include "Player.h"
#include "Properties.h"
#include "ZoneUtil.h"
#include "PacketUtil.h"
#include "Party.h"
#include "TradeManager.h"
#include "ParkingCenter.h"

#include <fstream>
#include <math.h>

#include "EffectDarkness.h"
#include "EffectVampirePortal.h"
#include "SlayerCorpse.h"
#include "VampireCorpse.h"
#include "MonsterCorpse.h"
#include "EffectDecayCorpse.h"
#include "EffectDecayItem.h"
//#include "EffectRevealer.h"
#include "EffectDecayMotorcycle.h"
#include "EffectCallMotorcycle.h"
#include "EffectAddItem.h"
#include "EffectDeleteItem.h"
#include "EffectTransportItem.h"
#include "EffectSanctuary.h"

#include "Gpackets/GCAddBurrowingCreature.h"
#include "Gpackets/GCAddVampireFromTransformation.h"
#include "Gpackets/GCAddMonsterFromTransformation.h"
#include "Gpackets/GCUntransformOK.h"
#include "Gpackets/GCUntransformFail.h"
#include "Gpackets/GCAddVampireFromBurrowing.h"
#include "Gpackets/GCAddMonsterFromBurrowing.h"
#include "Gpackets/GCAddWolf.h"
#include "Gpackets/GCAddBat.h"
#include "Gpackets/GCAddSlayerCorpse.h"
#include "Gpackets/GCAddVampireCorpse.h"
#include "Gpackets/GCAddMonsterCorpse.h"
#include "Gpackets/GCAddEffectToTile.h"
#include "Gpackets/GCAddVampirePortal.h"
#include "Gpackets/GCDeleteEffectFromTile.h"
#include "Gpackets/GCMineExplosionOK1.h"
#include "Gpackets/GCMineExplosionOK2.h"
#include "Gpackets/GCAddInstalledMineToZone.h"
#include "Gpackets/GCModifyInformation.h"

#include "Gpackets/GCFastMove.h"
#include "Gpackets/GCMove.h"
#include "Gpackets/GCMoveOK.h"
#include "Gpackets/GCMoveError.h"
#include "Gpackets/GCAddMonster.h"
#include "Gpackets/GCAddNewItemToZone.h"
#include "Gpackets/GCDropItemToZone.h"
#include "Gpackets/GCAddNPC.h"
#include "Gpackets/GCAddSlayer.h"
#include "Gpackets/GCAddVampire.h"
#include "Gpackets/GCDeleteObject.h"
#include "Gpackets/GCSetPosition.h"
#include "Gpackets/GCUnburrowOK.h"
#include "Gpackets/GCUnburrowFail.h"
#include "Gpackets/GCRemoveEffect.h"
#include "Gpackets/GCAddEffect.h"
#include "Gpackets/GCKnockBack.h"

#include "item/VampirePortalItem.h"
#include "Profile.h"

//#define __PROFILE_MOVEPCBROADCAST__

int g_FastMoveSearchX[8][4] =
{
	{ 0, 1, 1, 1 },     // LEFT
	{ 0, 1, 0, 1 },   // LEFTDOWN
	{ 0, 0, -1, 1 },    // DOWN
	{ 0, -1, 0, -1 },   // RIGHTDOWN
	{ 0, -1, -1, -1 },  // RIGHT
	{ 0, -1, 0, -1 },   // RIGHTUP
	{ 0, 0, -1, 1 },    // UP
	{ 0, 1, 0, 1 },     // LEFTUP
};

int g_FastMoveSearchY[8][4] =
{
	{ 0, 0, -1, 1 },    // LEFT
	{ 0, -1, -1, 0 },   // LEFTDOWN
	{ 0, -1, -1, -1 },  // DOWN
	{ 0, -1, -1, 0 },   // RIGHTDOWN
	{ 0, 0, -1, 1 },    // RIGHT
	{ 0, 1, 1, 0 },     // RIGHTUP
	{ 0, 1, 1, 1 },     // UP
	{ 0, 1, 1, 0 },     // LEFTUP
};

void
strlwr(char* str)
{
	while (*str!='\0')
	{
		*str = tolower( *str );

		str ++;
	}
}

//////////////////////////////////////////////////////////////////////////////
// 일반적인 몬스터들이 적으로 인식하느냐 마느냐 하는 함수
//////////////////////////////////////////////////////////////////////////////
bool isPotentialEnemy(Monster* pMonster, Creature* pCreature)
{
	Assert(pCreature != NULL);

	// 현재로서는 슬레이어는 무조건 적이다. 
	if (pCreature->isSlayer()) return true;

	if (pCreature->isVampire())
	{
		Vampire* pVampire = dynamic_cast<Vampire*>(pCreature);

		// 몬스터의 레벨이 뱀파이어의 레벨보다 10레벨 이상 높을 경우,
		// 적으로 인식한다.
		if ((pVampire->getLevel() + 10) <= pMonster->getLevel())
		{
			return true;
		}

		// 10레벨 이상인 뱀파이어는 적이다.
		if (pVampire->getLevel() > 10)
		{
			return true;
		}
	}

	return false;
}

//////////////////////////////////////////////////////////////////////////////
// STL find_if 알고리즘을 이용하기 위한 비교 클래스
//////////////////////////////////////////////////////////////////////////////
class isSameCreature 
{
public:
	isSameCreature(Creature* pCreature) : m_Creature(pCreature) {}

	bool operator () (Creature* pCreature) throw ()
	{
		return pCreature->getName() == m_Creature->getName();
	}
	
private :
	Creature* m_Creature;
};

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
Zone::Zone(ZoneID_t zoneID)
	throw ()
{
	m_Mutex.setName("Zone");
	m_MutexEffect.setName("ZoneEffect");

	m_ZoneID                  = zoneID;
	m_pZoneGroup              = NULL;
	m_Width                   = 0;
	m_Height                  = 0;
	m_pTiles                  = NULL;
	m_NPCCount                = 0;
	m_MonsterCount            = 0;
	m_pPCManager              = new PCManager();
	m_pNPCManager             = new NPCManager();
	m_pMonsterManager         = new MonsterManager(this);

	m_pEventMonsterManager    = new EventMonsterManager(this);

	m_pCombatMonsterManager   = new CombatMonsterManager(this); // 김경석

	m_pWeatherManager         = new WeatherManager(this);
	m_pEffectManager          = new EffectManager();
	m_pLockedEffectManager    = new EffectManager();
	m_pVampirePortalManager   = new EffectManager();
	m_pEffectScheduleManager  = new EffectScheduleManager();
	m_pLocalPartyManager      = new LocalPartyManager();
	m_pPartyInviteInfoManager = new PartyInviteInfoManager();
	m_pTradeManager           = new TradeManager;
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
Zone::Zone(ZoneID_t zoneID, ZoneCoord_t width, ZoneCoord_t height)
	throw ()
{
	__BEGIN_TRY

	m_Mutex.setName("Zone");
	m_MutexEffect.setName("ZoneEffect");

	m_ZoneID     = zoneID;
	m_pZoneGroup = NULL;
	m_Width      = width;
	m_Height     = height;
	m_pTiles     = NULL;

	Assert(m_ZoneID > 0);

	m_pTiles = new Tile* [ m_Width ];
	for (uint i = 0 ; i < m_Width ; i++) m_pTiles[i] = new Tile [m_Height];

	m_ppLevel = new (ZoneLevel_t*)[ m_Width ];
	for (uint i = 0; i < m_Width ; i++) m_ppLevel[i] = new ZoneLevel_t[m_Height];

	m_pPCManager              = new PCManager();
	m_pNPCManager             = new NPCManager();
	m_pMonsterManager         = new MonsterManager(this);

	m_pEventMonsterManager    = new EventMonsterManager(this);

	m_pCombatMonsterManager   = new CombatMonsterManager(this); // 김경석

	m_pWeatherManager         = new WeatherManager(this);
	m_pEffectManager          = new EffectManager();
	m_pLockedEffectManager    = new EffectManager();
	m_pVampirePortalManager   = new EffectManager();
	m_pEffectScheduleManager  = new EffectScheduleManager();
	m_pLocalPartyManager      = new LocalPartyManager();
	m_pPartyInviteInfoManager = new PartyInviteInfoManager();
	m_pTradeManager           = new TradeManager;

	__END_CATCH
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
Zone::~Zone ()
	throw ()
{
	__BEGIN_TRY
		
	if (m_pTiles != NULL) 
	{
		for (uint i=0 ; i<m_Width; i++) SAFE_DELETE_ARRAY(m_pTiles[i]);
		SAFE_DELETE_ARRAY(m_pTiles);
	}	

	if (m_ppLevel != NULL) 
	{
		for (uint i=0; i<m_Width; i++) SAFE_DELETE_ARRAY(m_ppLevel[i]);
		SAFE_DELETE_ARRAY(m_ppLevel);
	}	

	if (m_pSectors != NULL) 
	{
		for (int i=0; i<m_SectorWidth; i++) SAFE_DELETE_ARRAY(m_pSectors[i]);
		SAFE_DELETE_ARRAY(m_pSectors);
	}	

	SAFE_DELETE(m_pPCManager);
	SAFE_DELETE(m_pNPCManager);
	SAFE_DELETE(m_pMonsterManager);

	SAFE_DELETE(m_pEventMonsterManager);

	SAFE_DELETE(m_pCombatMonsterManager); // 김경석

	SAFE_DELETE(m_pWeatherManager);
	SAFE_DELETE(m_pEffectManager);
	SAFE_DELETE(m_pLockedEffectManager);
	SAFE_DELETE(m_pVampirePortalManager);
	SAFE_DELETE(m_pEffectScheduleManager);
	SAFE_DELETE(m_pLocalPartyManager);
	SAFE_DELETE(m_pPartyInviteInfoManager);

	__END_CATCH
}

//////////////////////////////////////////////////////////////////////////////
// initialize zone
//////////////////////////////////////////////////////////////////////////////
void Zone::init ()
	throw(Error)
{
	__BEGIN_TRY

	load();

	m_pWeatherManager->init();

	DarkLightInfo* pDIInfo = NULL;

	switch (m_ZoneType)
	{
		case ZONE_NORMAL_FIELD:
			pDIInfo = g_pDarkLightInfoManager->getCurrentDarkLightInfo();
			m_DarkLevel  = pDIInfo->getDarkLevel();
			m_LightLevel = pDIInfo->getLightLevel();
			break;
		case ZONE_NORMAL_DUNGEON:
		case ZONE_PC_VAMPIRE_LAIR:
		case ZONE_NPC_VAMPIRE_LAIR:
			m_DarkLevel = 15;
			m_LightLevel = 6;
			break;
		case ZONE_SLAYER_GUILD:
		case ZONE_RESERVED_SLAYER_GUILD:
		case ZONE_NPC_HOME:
		case ZONE_NPC_SHOP:
		case ZONE_RANDOM_MAP:
			m_DarkLevel  = 0;
			m_LightLevel = 14;
			break;
		default:
			pDIInfo = g_pDarkLightInfoManager->getCurrentDarkLightInfo();
			m_DarkLevel  = pDIInfo->getDarkLevel();
			m_LightLevel = pDIInfo->getLightLevel();
			break;
	}

	__END_CATCH
}

//////////////////////////////////////////////////////////////////////////////
// 존 파일에서 존 정보를 읽어서 로딩한다.
//////////////////////////////////////////////////////////////////////////////
void Zone::load(bool bOutput)
	throw(Error)
{
	__BEGIN_TRY
	__BEGIN_DEBUG
try {

	DWORD  versionLen;
	char   version[128];
	WORD   zoneID;
	WORD   zoneGroupID;
	DWORD  zonenameLen;
	char   zonename[128];
	BYTE   zoneType;
	BYTE   zoneLevel;
	DWORD  descLen;
	char*  pDesc = NULL;
	char   lwrFilename[256];

	ZoneInfo* pZoneInfo = g_pZoneInfoManager->getZoneInfo(m_ZoneID);

	// SMP 정보 파일을 연다.
	string SMPFilename = g_pConfig->getProperty("HomePath") + "/data/" + pZoneInfo->getSMPFilename();
	ifstream SMP(SMPFilename.c_str(), ios::in | ios::binary | ios::nocreate);
	if (!SMP)
	{
		strcpy( lwrFilename, SMPFilename.c_str());
		strlwr( lwrFilename );
		SMP.open(lwrFilename, ios::in | ios::binary | ios::nocreate);

		//cout << "second chk : " << lwrFilename << endl;

		if (!SMP)
		{
			StringStream msg;
			msg << SMPFilename << " not exist or cannot open it";
			cerr << msg.toString() << endl;
			throw FileNotExistException(msg.toString());
		}
	}

    // read zone version
	SMP.read(&versionLen,szDWORD);
	SMP.read(version,versionLen);
	version[versionLen] = 0;
	
	// read zone id
	SMP.read(&zoneID,szWORD);
	
	// read zone group id (no use)
	SMP.read(&zoneGroupID,szWORD);
	
	// read zone name
	SMP.read(&zonenameLen,szDWORD);
	if (zonenameLen > 0)
	{
		SMP.read(zonename,zonenameLen);
		zonename[zonenameLen] = 0;
	}

    // read zone type & level 
	SMP.read(&zoneType,szBYTE);
	SMP.read(&zoneLevel,szBYTE);

	// read zone description
	SMP.read(&descLen,szDWORD);
	if (descLen > 0)
	{
		pDesc = new char[descLen+1];
		SMP.read(pDesc,descLen);
		pDesc[descLen] = 0;
	
		SAFE_DELETE_ARRAY(pDesc);	// add '_ARRAY' moved to here.. by sigi 2002.5.2
	}

	// read zone width & height
	SMP.read(&m_Width, szWORD);
	SMP.read(&m_Height ,szWORD);

	Assert(m_Width <= maxZoneWidth);
	Assert(m_Height <= maxZoneHeight);

	// 타일을 2차원배열로 만들어 메모리를 할당한다.
	m_pTiles = new Tile* [ m_Width ];
	for (uint i = 0 ; i < m_Width ; i++) 
	{
		m_pTiles[i] = new Tile [m_Height];
	}

	// 섹터를 2차원 배열로 만들어 메모리를 할당한다.
	m_SectorWidth = (int)ceil((float)m_Width/(float)SECTOR_SIZE);
	m_SectorHeight = (int)ceil((float)m_Height/(float)SECTOR_SIZE);
	m_pSectors = new (Sector*)[m_SectorWidth];
	for (int x=0; x<m_SectorWidth; x++)
	{
		m_pSectors[x] = new Sector[m_SectorHeight];
	}

	// 각각의 타일에다가 섹터 포인터를 세팅한다.
	for (int x=0; x<m_Width; x++)
	{
		for (int y=0; y<m_Height; y++)
		{
			int sx = x/SECTOR_SIZE;
			int sy = y/SECTOR_SIZE;

			Assert(sx < m_SectorWidth && sy < m_SectorHeight);

			m_pTiles[x][y].setSector(&m_pSectors[sx][sy]);
		}
	}

	// 섹터끼리 연결을 한다.
	VSRect srect(0, 0, m_SectorWidth-1, m_SectorHeight-1);
	for (int x=0; x<m_SectorWidth; x++)
	{
		for (int y=0; y<m_SectorHeight; y++)
		{
			for (uint d=0; d<9; d++)
			{
				int sectorx = x + dirMoveMask[d].x;
				int sectory = y + dirMoveMask[d].y;

				if (srect.ptInRect(sectorx, sectory))
				{
					m_pSectors[x][y].setNearbySector(d, &m_pSectors[sectorx][sectory]);
				}
			}
		}
	}

	// MonsterAI를 위해 존의 영역을 구분지어놓은 사각형을 생성한다.
	m_OuterRect.set(0, 0, m_Width-1, m_Height-1);
	if (m_Width > 64 && m_Height > 64)
	{
		m_InnerRect.set(15, 15, m_Width-15, m_Height-15);
		m_CoreRect.set(25, 25, m_Width-25, m_Height-25);
	}

	for (ZoneCoord_t y=0; y<m_Height; y++)
	{
		for (ZoneCoord_t x=0; x<m_Width; x++)
		{
			BYTE flag = 0;
			SMP.read(&flag, szBYTE);

			// 순서대로 지하, 지상, 공중 블록
			if (flag & 0x01) m_pTiles[x][y].setBlocked(Creature::MOVE_MODE_BURROWING);
			if (flag & 0x02) m_pTiles[x][y].setBlocked(Creature::MOVE_MODE_WALKING);
			if (flag & 0x04) m_pTiles[x][y].setBlocked(Creature::MOVE_MODE_FLYING);

			// 아무것도 없는 경우..
			// 몹 생성을 위한 좌표정보를 만들어둔다.
			if (flag==0 && m_InnerRect.ptInRect( x, y ))
			{
				m_MonsterRegenPositions.push_back( BPOINT( (BYTE)x, (BYTE)y ) );
			}

			// 포탈 정보
			if (flag & 0x80)
			{
				BYTE	type;
				ZoneID_t targetZoneID;
				BYTE     targetX, targetY;
				SMP.read(&type, szBYTE);

				if (type == PORTAL_NORMAL)
				{
					SMP.read(&targetZoneID, szZoneID);
					SMP.read(&targetX,      szBYTE);
					SMP.read(&targetY,      szBYTE);

					// 포탈을 생성해 준다.
					NormalPortal* pNormalPortal = new NormalPortal();
					pNormalPortal->setObjectType(PORTAL_NORMAL);
					pNormalPortal->setZoneID(targetZoneID);
					pNormalPortal->setX(targetX);
					pNormalPortal->setY(targetY);

					getObjectRegistry().registerObject(pNormalPortal);
					m_pTiles[x][y].addPortal(pNormalPortal);

					if (bOutput)
					{
						cout << "Normal(" << (int)x << "," << (int)y << "," << (int)targetZoneID << "," << (int)targetX << "," << (int)targetY << ")" << endl;
					}
				}
				else if (type == PORTAL_SLAYER)
				{
					SMP.read(&targetZoneID, szZoneID);
					SMP.read(&targetX,      szBYTE);
					SMP.read(&targetY,      szBYTE);

					// 포탈을 생성해 준다.
					NormalPortal* pNormalPortal = new NormalPortal();
					pNormalPortal->setObjectType(PORTAL_SLAYER);
					pNormalPortal->setZoneID(targetZoneID);
					pNormalPortal->setX(targetX);
					pNormalPortal->setY(targetY);

					getObjectRegistry().registerObject(pNormalPortal);
					m_pTiles[x][y].addPortal(pNormalPortal);

					if (bOutput)
					{
						cout << "Slayer(" << (int)x << "," << (int)y << "," << (int)targetZoneID << "," << (int)targetX << "," << (int)targetY << ")" << endl;
					}
				}
				else if (type == PORTAL_VAMPIRE)
				{
					SMP.read(&targetZoneID, szZoneID);
					SMP.read(&targetX,      szBYTE);
					SMP.read(&targetY,      szBYTE);

					// 포탈을 생성해 준다.
					NormalPortal* pNormalPortal = new NormalPortal();
					pNormalPortal->setObjectType(PORTAL_VAMPIRE);
					pNormalPortal->setZoneID(targetZoneID);
					pNormalPortal->setX(targetX);
					pNormalPortal->setY(targetY);

					getObjectRegistry().registerObject(pNormalPortal);
					m_pTiles[x][y].addPortal(pNormalPortal);

					if (bOutput)
					{
						cout << "Vampire(" << (int)x << "," << (int)y << "," << (int)targetZoneID << "," << (int)targetX << "," << (int)targetY << ")" << endl;
					}
				}
				else if (type == PORTAL_MULTI_TARGET)
				{
					BYTE size;
					SMP.read(&size, szBYTE);

					// 포탈을 생성해 준다.
					MultiPortal* pMultiPortal = new MultiPortal();

					for(int i = 0; i < size; i++) 
					{
						SMP.read(&targetZoneID, szZoneID);
						SMP.read(&targetX,      szBYTE);
						SMP.read(&targetY,      szBYTE);

						pMultiPortal->setObjectType(PORTAL_SLAYER);

						// 타겟 인포를 구성한다.
						PortalTargetInfo* pPortalTargetInfo = new PortalTargetInfo();
						pPortalTargetInfo->setZoneID(targetZoneID);
						pPortalTargetInfo->setX(targetX);
						pPortalTargetInfo->setY(targetY);
						pMultiPortal->setPortalTargetInfo(pPortalTargetInfo);
					}

					getObjectRegistry().registerObject(pMultiPortal);
					m_pTiles[x][y].addPortal(pMultiPortal);

					if (bOutput)
					{
						cout << "Multi(" << (int)x << "," << (int)y << "," << (int)targetZoneID << "," << (int)targetX << "," << (int)targetY << ")" << endl;
					}
				}
				else if ( type == PORTAL_GUILD )
				{
					SMP.read(&targetZoneID, szZoneID);
					SMP.read(&targetX,      szBYTE);
					SMP.read(&targetY,      szBYTE);

					// 포탈을 생성해 준다.
					GuildPortal* pGuildPortal = new GuildPortal();
					pGuildPortal->setObjectType( PORTAL_GUILD );
					pGuildPortal->setZoneID( targetZoneID );
					pGuildPortal->setX( targetX );
					pGuildPortal->setY( targetY );

					getObjectRegistry().registerObject(pGuildPortal);
					m_pTiles[x][y].addPortal(pGuildPortal);

					if (bOutput)
					{
						cout << "Guild(" << (int)x << "," << (int)y << "," << (int)targetZoneID << "," << (int)targetX << "," << (int)targetY << ")" << endl;
					}

				}
				else if ( type == PORTAL_BATTLE )
				{
					SMP.read(&targetZoneID, szZoneID);
					SMP.read(&targetX,      szBYTE);
					SMP.read(&targetY,      szBYTE);

					// 포탈을 생성해 준다.
					NormalPortal* pNormalPortal = new NormalPortal();
					pNormalPortal->setObjectType(PORTAL_SLAYER);
					pNormalPortal->setZoneID(targetZoneID);
					pNormalPortal->setX(targetX);
					pNormalPortal->setY(targetY);

					getObjectRegistry().registerObject(pNormalPortal);
					m_pTiles[x][y].addPortal(pNormalPortal);

					if (bOutput)
					{
						cout << "Slayer(" << (int)x << "," << (int)y << "," << (int)targetZoneID << "," << (int)targetX << "," << (int)targetY << ")" << endl;
					}
				}
				else
				{
				}

			} //if (flag & 0x80)
		} // for 
	} // for

	SMP.close();

	///*
	if (m_MonsterRegenPositions.size()==0)
	{
		cout << "MonsterRegenPosition not exist" << endl;
		cout << "Width = " << m_Width << endl;
		cout << "Height = " << m_Height << endl;

		//Assert(m_MonsterRegenPositions.size()!=0);

		ZoneCoord_t outerMinX = m_Width/7;
		ZoneCoord_t outerMinY = m_Height/7;
		ZoneCoord_t outerMaxX = m_Width-outerMinX;
		ZoneCoord_t outerMaxY = m_Width-outerMinY;

		for (ZoneCoord_t y=outerMinY; y<outerMaxY; y++)
		{
			for (ZoneCoord_t x=outerMinX; x<outerMaxX; x++)
			{
				Tile& rTile = m_pTiles[x][y];

				if (!rTile.hasPortal() 
					&& !rTile.isGroundBlocked()
					&& !rTile.isAirBlocked()
					&& !rTile.isUndergroundBlocked())
				{
					m_MonsterRegenPositions.push_back( BPOINT( (BYTE)x, (BYTE)y ) );
				}
			}
		}

		Assert(m_MonsterRegenPositions.size()!=0);
	}
	//*/

	// Zone 정보를 세팅한다.
	m_ZoneType  = pZoneInfo->getZoneType();
	m_ZoneLevel = pZoneInfo->getZoneLevel();

	// 메모리 할당해주고...
	m_ppLevel = new (ZoneLevel_t*) [ m_Width ];
	for (uint i = 0; i < m_Width; i++)
		m_ppLevel[i] = new ZoneLevel_t[m_Height];

	// 존 레벨을 디폴트 값으로 초기화시킨다.
	for (ZoneCoord_t x = 0; x < m_Width; x++)
		for (ZoneCoord_t y = 0; y < m_Height; y++)
			m_ppLevel[x][y] = m_ZoneLevel;

	// SSI 정보 파일을 연다.
	string SSIFilename = g_pConfig->getProperty("HomePath") + "/data/" + pZoneInfo->getSSIFilename();
	ifstream SSI(SSIFilename.c_str(), ios::in | ios::binary | ios::nocreate);
	if (!SSI)
	{
		strcpy( lwrFilename, SSIFilename.c_str());
		strlwr( lwrFilename );
		SSI.open(lwrFilename, ios::in | ios::binary | ios::nocreate);

		//cout << "second chk : " << lwrFilename << endl;

		if (!SSI)
		{
			StringStream msg;
			msg << SSIFilename << " not exist or cannot open it";
			throw FileNotExistException(msg.toString());
		}
	}

	int size = 0;
	SSI.read(&size, szint);

	BYTE left, top, right, bottom, level;
	for (int i=0; i<size; i++)
	{
		SSI.read(&level, szBYTE);
		SSI.read(&left, szBYTE);
		SSI.read(&top, szBYTE);
		SSI.read(&right, szBYTE);
		SSI.read(&bottom, szBYTE);

		if (bOutput)
		{
			cout << "LEVEL:" << (int)level << ",(" << (int)left << "," << (int)top << "," << (int)right << "," << (int)bottom << ")" << endl;
		}

		Assert(left <= right);
		Assert(top  <= bottom);

		for (int bx=left; bx<=right; bx++)
			for (int by=top; by<=bottom; by++)
				m_ppLevel[bx][by] = level;
	}

	SSI.close();

	// 트리거드 포탈을 로드한다.
	loadTriggeredPortal();

	// 몬스터 로드하고....
	m_pMonsterManager->load();


//#ifdef __XMAS_EVENT_CODE__
	cout << "Begin Event Monster Loading..." << endl;
	m_pEventMonsterManager->load();
	cout << "Event Monster Loading Completed..." << endl;
//#endif

	cout << "Begin Combat Monster Loading..." << endl;
	m_pCombatMonsterManager->load();
	cout << "Combat Monster Loading Completed..." << endl;

	// 아이템 로드한다.
	loadItem();
	// NPC 를 로딩한다.
	m_pNPCManager->load(m_ZoneID);

	// 스프라이트 갯수를 초기화한다.
	initSpriteCount();
} catch ( Throwable& t )
{ cout << t.toString() << endl; Assert(false);}

	__END_DEBUG
	__END_CATCH
}

// g_pCombatSystemManager를 통해서 접근
void Zone::ActiveCombatMonster() 
	throw(Error) 
{
	m_pCombatMonsterManager->activeMonster();
}

// g_pCombatSystemManager를 통해서 접근
void Zone::DeactiveCombatMonster() 
	throw(Error) 
{
	m_pCombatMonsterManager->deactiveMonster();
}

//////////////////////////////////////////////////////////////////////////////
// load items from database
// * NOTE *
// 현재 바닥에 떨어진 아이템은 서버가 재시작되어도 로딩하지 않는다.
//////////////////////////////////////////////////////////////////////////////
void Zone::loadItem () 
	throw(Error)
{
	__BEGIN_TRY

	/*
	// 아이템 로딩...........
	g_pItemLoaderManager->load(this);

	// 아이템은 다 날려버렸지만...그래두...
	// 아이템 오브젝트 아이디를 재 할당 받고 다시 저장한다.
	for (int j = 0; j < m_Height; j++) 
	{
		for (int i = 0; i < m_Width; i++) 
		{
			if (m_pTiles[i][j].hasItem()) 
			{
				Item* pItem = m_pTiles[i][j].getItem();
				m_ObjectRegistry.registerObject(pItem);
				pItem->save("", STORAGE_ZONE, m_ZoneID, i, j);
				addToItemList(pItem);

				if (pItem->getItemClass() == Item::ITEM_CLASS_MOTORCYCLE) 
				{
					Motorcycle* pMotorcycle = dynamic_cast<Motorcycle*>(pItem);
					MotorcycleBox* pMotorcycleBox = new MotorcycleBox(pMotorcycle, this, i, j);
					g_pParkingCenter->addMotorcycleBox(pMotorcycleBox);
				}
			}
		}
	}
	*/

	__END_CATCH
}

//////////////////////////////////////////////////////////////////////////////
// 현재 존에 트리거드 포탈을 로드한다.
//////////////////////////////////////////////////////////////////////////////
void Zone::loadTriggeredPortal ()
	throw(Error)
{
	__BEGIN_TRY

	Statement* pStmt   = NULL;
	Result*    pResult = NULL;

	BEGIN_DB
	{
		pStmt   = g_pDatabaseManager->getConnection("DARKEDEN")->createStatement();
		pResult = pStmt->executeQuery("SELECT X1, Y1, X2, Y2 FROM ZoneTriggers WHERE ZoneID=%d", m_ZoneID);

		while (pResult->next())
		{
			int left   = pResult->getInt(1);
			int top    = pResult->getInt(2);
			int right  = pResult->getInt(3);
			int bottom = pResult->getInt(4);

			Assert(left <= right);
			Assert(top <= bottom);
			
			Assert(m_OuterRect.ptInRect(left, top));
			Assert(m_OuterRect.ptInRect(right, bottom));

			for (int x=left; x<=right; x++)
			{
				for (int y=top; y<=bottom; y++)
				{
					if (getTile(x,y).hasPortal())
					{
						//cerr << "loadTriggeredPortal : 이미 포탈이 존재합니다." << endl;
						//cerr << "ZONEID:" << m_ZoneID << ",X:" << x << "Y:" << y << endl;
						getTile(x,y).deletePortal();
					}

					// 포탈을 생성하고, 등록한다.
					TriggeredPortal* pPortal = new TriggeredPortal();
					getObjectRegistry().registerObject(pPortal);

					// 포탈 내용을 로드한다.
					pPortal->setObjectType(PORTAL_NORMAL);
					pPortal->load(m_ZoneID, left, top, right, bottom);
					
					// 타일에다 포탈을 붙인다.
					getTile(x, y).addPortal(pPortal);
				}
			}
		}

		SAFE_DELETE(pStmt);
	}
	END_DB(pStmt);

	__END_CATCH
}

//////////////////////////////////////////////////////////////////////////////
// 이 존에서 나타나는 NPC와 몬스터의 스프라이트갯수를 계산해둔다.
//////////////////////////////////////////////////////////////////////////////
void Zone::initSpriteCount () 
	throw(Error)
{
	__BEGIN_TRY

	m_NPCCount = 0;
	m_MonsterCount = 0;

	// NPC 스프라이트 타입의 갯수를 계산한다.
	hash_map<ObjectID_t, Creature*> NPCMap = m_pNPCManager->getCreatures();
	for (hash_map<ObjectID_t, Creature*>::const_iterator i = NPCMap.begin(); i != NPCMap.end(); i++)
	{
		NPC* pNPC = dynamic_cast<NPC*>(i->second);
		bool bAdd = true;
		
		for (int j=0; j<m_NPCCount; j++) // 현재 있는 몬스터 타입 중에서 
		{
			if (pNPC->getSpriteType() == m_NPCTypes[j])
			{
				bAdd = false;
				break;
			}
		}

		if (bAdd)
		{
			m_NPCTypes[m_NPCCount] = pNPC->getSpriteType();
			m_NPCCount++;
		}
	}

	// 몬스터 스프라이트 타입의 갯수를 계산한다.
	hash_map<SpriteType_t, MonsterCounter*> MONSTER = m_pMonsterManager->getMonsters();
	for (hash_map<SpriteType_t, MonsterCounter*>::const_iterator i = MONSTER.begin(); i != MONSTER.end(); i++)
	{
		Assert ( m_MonsterCount < maxMonsterPerZone );	// by sigi

		m_MonsterTypes[m_MonsterCount] = i->first;
		m_MonsterCount++;
	}

	__END_CATCH
}

//////////////////////////////////////////////////////////////////////////////
// 타일에 지정된 존 레벨을 리턴한다.
//////////////////////////////////////////////////////////////////////////////
ZoneLevel_t Zone::getZoneLevel(ZoneCoord_t x, ZoneCoord_t y) const 
	throw(OutOfBoundException)
{
	__BEGIN_TRY

	Assert(x < m_Width && y < m_Height);
	return m_ppLevel[x][y];

	__END_CATCH
}

//////////////////////////////////////////////////////////////////////////////
// getTile
//////////////////////////////////////////////////////////////////////////////
const Tile & Zone::getTile(ZoneCoord_t x, ZoneCoord_t y) const 
    throw(OutOfBoundException)
{
	__BEGIN_TRY

	Assert(x < m_Width && y < m_Height);
	return m_pTiles[x][y];
	
	__END_CATCH
}

Tile & Zone::getTile(ZoneCoord_t x, ZoneCoord_t y) 
    throw(OutOfBoundException)
{
	__BEGIN_TRY

	Assert(x < m_Width && y < m_Height);
	return m_pTiles[x][y];
	
	__END_CATCH
}

//////////////////////////////////////////////////////////////////////////////
// getSector
//////////////////////////////////////////////////////////////////////////////
Sector* Zone::getSector(ZoneCoord_t x, ZoneCoord_t y) 
    throw(OutOfBoundException)
{
	__BEGIN_TRY

	Assert(x < m_Width && y < m_Height);

	int sx = x/SECTOR_SIZE;
	int sy = y/SECTOR_SIZE;

	Assert(sx < m_SectorWidth && y < m_SectorHeight);

	return &(m_pSectors[sx][sy]);

	__END_CATCH
}

//////////////////////////////////////////////////////////////////////////////
// 기본적으로 Zone 의 처리는 mutex 를 사용하지 않는다.
// 왜냐하면, ZoneGroupThread의 단일 처리를 받기 때문이다. 그런데, 새로 존에 
// PC를 추가하는 것은 IPM에서 이루어지게 되므로, 이런 연유로 mutex 멤버를
// 추가해야 하며, 아래 메소드에 locking 을 걸어줘야 한다.
//////////////////////////////////////////////////////////////////////////////
void Zone::pushPC(Creature* pCreature)
	throw(Error)
{
	__BEGIN_TRY 

	Assert(pCreature != NULL);

	__ENTER_CRITICAL_SECTION(m_Mutex)

	m_PCListQueue.push_back(pCreature);
	//m_PCQueue.push(pCreature);
	
	__LEAVE_CRITICAL_SECTION(m_Mutex)

	__END_CATCH
}

//////////////////////////////////////////////////////////////////////////////
// P(cx,cy)에 있는 PC를 dir 방향으로 이동시켜 Q(nx,ny)로 옮긴다.
// 그리고나서, 주변의 PC들에게 이동 정보를 브로드캐스트한다. 
//
// *CAUTION*
// PC가 아닌 크리처(NPC,Monster)의 이동은 moveCreature를 사용한다.
//////////////////////////////////////////////////////////////////////////////
void Zone::movePC(Creature* pCreature, ZoneCoord_t cx, ZoneCoord_t cy, Dir_t dir)
	throw(ProtocolException, Error)
{
	__BEGIN_TRY

	Assert(pCreature->isPC());

	Player* pPlayer = pCreature->getPlayer();
	Assert(pPlayer != NULL);

	if (dir >= DIR_MAX || !isAbleToMove(pCreature))
	{
		GCMoveError 	gcMoveError(pCreature->getX(), pCreature->getY());
		pPlayer->sendPacket(&gcMoveError);
		return;
	}

	const int threshold = 6;
	////////////////////////////////////////////////////////////
	// 일단 크리처가 점프를 하려는 건지를 체크한다.
	// 만약 약간 점프했을 경우, GCMoveError 패킷을 전송한다.
	// 
	// OX, OY : 플레이어의 현재 좌표
	// CX, CY : 타겟 좌표
	//
	// max(0, OX - threshold) <= CX <= min(OX + threshold, ZONEWIDTH-1)
	// max(0, OY - threshold) <= CY <= min(OY + threshold, ZONEHEIGHT-1)
	// 를 만족해야 정상적인 이동이다.
	////////////////////////////////////////////////////////////
	if (pCreature->getX() != cx || pCreature->getY() != cy) 
	{
		if (cx >= max(0           , pCreature->getX() - threshold) && 
			cx <= min(m_Width - 1 , pCreature->getX() + threshold) && 
			cy >= max(0           , pCreature->getY() - threshold) && 
			cy <= min(m_Height - 1, pCreature->getY() + threshold)) 
		{
			// 허용가능한 오차 범위내에서의 점프는 그냥 무시해준다.

			/*// 주석처리 by sigi - 안 보내는게 맞는 듯.. 
			GCMoveError gcMoveError;
			gcMoveError.setX(cx);
			gcMoveError.setY(cy);
			pCreature->getPlayer()->sendPacket(&gcMoveError);
			*/
			return;
		} 
		else 
		{
			// 허용가능한 오차 범위를 넘어설 경우 접속을 차단한다.
			//StringStream msg;
			//msg << pCreature->getName() << " try to jump from (" 
			//	<< (int)pCreature->getX() << "," << (int)pCreature->getY()
			//	<< ") to (" << (int)cx << "," << (int)cy << ")";

			GCMoveError 	gcMoveError(cx, cy); 
			pPlayer->sendPacket(&gcMoveError);
			return;
		}
	}

	// 다음 좌표를 계산한다.
	int nx = cx;
	int ny = cy;

	//////////////////////////////////////////////////////////////////////////////
	// *CAUTION*
	// 경계지점에서 경계의 외곽으로 움직이는 패킷이 날아와서는 안된다.
	// ex> (0,10)에서 LEFT 이동은 날아올 수 없다. (10,0)에서 UP 이동도 마찬가지이다.
	//////////////////////////////////////////////////////////////////////////////
	nx = nx + dirMoveMask[dir].x;
	ny = ny + dirMoveMask[dir].y;

	VSRect rect(0, 0, m_Width-1, m_Height-1);
	if (!rect.ptInRect(nx, ny)) throw InvalidProtocolException("invalid coordination");

	////////////////////////////////////////////////////////////
	// 이동할 곳이 block 되어있다면, GCMoveError 를 전송한다.
	// (PC와 같은 위치가 block 되어야 한다.)
	////////////////////////////////////////////////////////////
	Tile& newTile = m_pTiles[nx][ny];
	if (newTile.isBlocked(pCreature->getMoveMode())
		// Sanctuary 이펙트가 걸려있다면 못 간다.
        || newTile.hasEffect() && newTile.getEffect(Effect::EFFECT_CLASS_SANCTUARY))
	{
		GCMoveError 	gcMoveError(cx, cy); 
		pPlayer->sendPacket(&gcMoveError);
	} 
	else
	{ 
		// 우선 크리처의 좌표를 변경한다.
		pCreature->setXYDir(nx, ny, dir);

		try 
		{
			// 이전 타일에서 크리처를 삭제한다.
			m_pTiles[cx][cy].deleteCreature(pCreature->getObjectID());	

			// 새 타일에 크리처를 추가한다.
			if (!newTile.addCreature(pCreature))
			{
				// Portal을 activate 시킨 경우이다. by sigi. 2002.5.6
				return;
			}

			try {
				checkMine(this, pCreature, nx, ny);
			} catch ( Throwable & t ) {
				filelog("CheckMineBug.txt", "%s : %s", "movePC", t.toString().c_str());
			}

			// 클라이언트에게 GCMoveOK 를 전송할때, (nx,ny)는 도착 좌표여야 하며,
			// dir 은 바라보는(이동할) 방향이어야 한다. 그것이 현재의 정책!
			GCMoveOK gcMoveOK(nx,ny,dir);
			pPlayer->sendPacket(&gcMoveOK);
	
			// 자동으로 GCMove/GCAddSlayer/GCAddVampire 패킷을 브로드캐스트한다.
			#ifdef __PROFILE_MOVEPCBROADCAST__
				beginProfileEx("Zone::movePCBroadcast");
				movePCBroadcast(pCreature, cx, cy, nx, ny);
				endProfileEx("Zone::movePCBroadcast");
			#else
				movePCBroadcast(pCreature, cx, cy, nx, ny);
			#endif
		} 
		catch (NoSuchElementException & nsee) 
		{
			throw Error("이전 타일에 크리처가 존재하지 않습니다.");
		} 
		catch (DuplicatedException & de) 
		{
			throw Error("새 타일에 크리처가 이미 존재합니다.");
		} 
		catch (PortalException&) 
		{
		}
		catch (Error& e)
		{
			filelog("assertTile.txt", "Zone::movePC : %s", e.toString().c_str());
			throw;
		}
	}

	__END_CATCH
}

//////////////////////////////////////////////////////////////////////////////
// PC가 아닌 크리처(NPC,Monster)를 움직일 때 이 메소드를 사용한다.
//
// *CAUTION*
//
// 이때, (nx,ny,dir)은 크리처가 도달할 다음 좌표와 바라보는 방향을 나타낸다.
// 그리고, 이 좌표에 아무 것도 없다는 검증이 먼저 이루어져야 한다. (길찾기 루틴)
//////////////////////////////////////////////////////////////////////////////
void Zone::moveCreature(Creature* pCreature, ZoneCoord_t nx, ZoneCoord_t ny, Dir_t dir)
	throw(ProtocolException, Error)
{
	__BEGIN_TRY

	ZoneCoord_t cx = pCreature->getX();
	ZoneCoord_t cy = pCreature->getY();

	// 이전 타일에서 크리처를 삭제하고, 다음 타일에 크리처를 추가한다. 
	try 
	{
		// 이전 타일에서 크리처를 삭제한다.
		m_pTiles[cx][cy].deleteCreature(pCreature->getObjectID());

		// 도착 타일에 크리처를 추가한다.
		m_pTiles[nx][ny].addCreature(pCreature);

		try {
			checkMine(this, pCreature, nx, ny);
		} catch ( Throwable & t ) {
			filelog("CheckMineBug.txt", "%s : %s", "moveCreature", t.toString().c_str());
		}

	} 
	catch (NoSuchElementException & nsee) 
	{
		throw Error("이전 타일에 크리처가 존재하지 않습니다.");
	}
	catch (DuplicatedException & de) 
	{
		throw Error("새 타일에 크리처가 이미 존재합니다.");
	}
	catch (Error& e)
	{
		filelog("assertTile.txt", "Zone::moveCreature : %s", e.toString().c_str());
		throw;
	}

// 크리처의 좌표와 방향을 설정한다.
pCreature->setXYDir(nx, ny, dir);

	// 알아서 GCMove 랑 GCAddMonster/GCAddNPC 를 브로드캐스트한다.
	moveCreatureBroadcast(pCreature, cx, cy, nx, ny);

	__END_CATCH
}

//////////////////////////////////////////////////////////////////////////////
// add PC
//
// PC 를 존에 최초로 추가한다. PC 주변의 다른 PC들에게 새 크리처의 출현을 알려주고,
// 주변을 스캔해서 객체들의 정보를 받아온다.
//////////////////////////////////////////////////////////////////////////////
void Zone::addPC(Creature* pCreature, ZoneCoord_t cx, ZoneCoord_t cy, Dir_t dir)
	throw(EmptyTileNotExistException, Error)
{
	__BEGIN_TRY
	__BEGIN_DEBUG

	Assert(pCreature != NULL);
	Assert(pCreature->isPC());

	TPOINT pt = findSuitablePosition(this, cx, cy, pCreature->getMoveMode());

	if (pt.x != -1) 
	{ 
		// 지정된 좌표를 클라이언트로 전송한다.
		GCSetPosition gcSetPosition;
		gcSetPosition.setX(pt.x);
		gcSetPosition.setY(pt.y);
		gcSetPosition.setDir(dir);
	
		pCreature->getPlayer()->sendPacket(&gcSetPosition);

		// 크리처의 좌표와 방향을 지정한다.
		pCreature->setXYDir(pt.x, pt.y, dir);

		// 적절한 흌일을 찾았으면, 크리처를 실제로 
		// PC매니저와 타일에 각각 집어넣는다.
		m_pTiles[pt.x][pt.y].addCreature(pCreature);

		//checkMine(this, pCreature, pt.x, pt.y);	// 여기서도 mine을 폭발시켜야 하나..?
	
		m_pPCManager->addCreature(pCreature);
	
		if (pCreature->isSlayer()) 
		{
			((Slayer*)pCreature)->sendRealWearingInfo();
			((Slayer*)pCreature)->sendSlayerSkillInfo();
		} 
		else 
		{
			((Vampire*)pCreature)->sendRealWearingInfo();
			((Vampire*)pCreature)->sendVampireSkillInfo();
		}

		GCModifyInformation gcModifyInformation;

		if (pCreature->isSlayer())
		{
			Slayer* pNewSlayer = dynamic_cast<Slayer*>(pCreature);
			Assert(pNewSlayer != NULL);

			Player* pPlayer = pNewSlayer->getPlayer();
			Assert(pPlayer != NULL);

			gcModifyInformation.addShortData(MODIFY_DEFENSE,    pNewSlayer->getDefense());
			gcModifyInformation.addShortData(MODIFY_PROTECTION, pNewSlayer->getProtection());
			gcModifyInformation.addShortData(MODIFY_TOHIT,      pNewSlayer->getToHit());
			gcModifyInformation.addShortData(MODIFY_MIN_DAMAGE, pNewSlayer->getDamage(ATTR_CURRENT));
			gcModifyInformation.addShortData(MODIFY_MAX_DAMAGE, pNewSlayer->getDamage(ATTR_MAX));

			pPlayer->sendPacket(&gcModifyInformation);
		}
		else if (pCreature->isVampire())
		{
			Vampire* pNewVampire = dynamic_cast<Vampire*>(pCreature);
			Assert(pNewVampire != NULL);

			Player* pPlayer = pNewVampire->getPlayer();
			Assert(pPlayer != NULL);

			gcModifyInformation.addShortData(MODIFY_DEFENSE,    pNewVampire->getDefense());
			gcModifyInformation.addShortData(MODIFY_PROTECTION, pNewVampire->getProtection());
			gcModifyInformation.addShortData(MODIFY_TOHIT,      pNewVampire->getToHit());
			gcModifyInformation.addShortData(MODIFY_MIN_DAMAGE, pNewVampire->getDamage(ATTR_CURRENT));
			gcModifyInformation.addShortData(MODIFY_MAX_DAMAGE, pNewVampire->getDamage(ATTR_MAX));

			pPlayer->sendPacket(&gcModifyInformation);
		}

		// 주변의 PC들에게 알릴 GCAddSlayer or GCAddVampire 패킷을 생성한다.
		Creature::CreatureClass CClass = pCreature->getCreatureClass();
		if (CClass == Creature::CREATURE_CLASS_SLAYER)
		{
			Slayer* pSlayer = dynamic_cast<Slayer*>(pCreature);
			GCAddSlayer gcAddSlayer;
			makeGCAddSlayer(&gcAddSlayer, pSlayer);

			scan(pCreature, pt.x, pt.y, &gcAddSlayer);
		}
		else if (CClass == Creature::CREATURE_CLASS_VAMPIRE)
		{
			Vampire* pVampire = dynamic_cast<Vampire*>(pCreature);
			GCAddVampire gcAddVampire;
			makeGCAddVampire(&gcAddVampire, pVampire);

			scan(pCreature, pt.x, pt.y, &gcAddVampire);

			// 뱀파이어라면 포탈을 이용해 왔을 가능성이 있으므로,
			// 플래그를 꺼준다.
			if (pVampire->isFlag(Effect::EFFECT_CLASS_VAMPIRE_PORTAL))
			{
				pVampire->removeFlag(Effect::EFFECT_CLASS_VAMPIRE_PORTAL);
			}
		}
		else
		{
			throw Error("invalid creature class. must be slayer or vampire...");
		}

		// 파티에 가입되어 있다면 로컬 파티에 가입시킨다.
		uint PartyID = pCreature->getPartyID();
		if (PartyID != 0)
		{
			// 파티가 있다면 걍 더한다.
			m_pLocalPartyManager->addPartyMember(PartyID, pCreature);
		}
	} 
	else 
	{
		ZoneCoord_t tempX = Random(20, m_Width);
		ZoneCoord_t tempY = Random(20, m_Height);
		addPC(pCreature, tempX, tempY, 0);

		// 맥스카운트 지나도 못 찾은 경우 Assert
		//throw EmptyTileNotExistException("too many pc in this zone.. or too unlucky");
	}

	__END_DEBUG
	__END_CATCH
}

//////////////////////////////////////////////////////////////////////////////
// detect invisibility등의 효과가 사라진 경우..보이는 놈이 안보이게 될 경우
// pCreature에게 GCDeleteObject를 보내준다. 보고 있던 invisible creature를
// delete한다. 또는 안보인는 넘이 보이게 될 경우등..
//////////////////////////////////////////////////////////////////////////////
void Zone::updateInvisibleScan(Creature* pCreature)
	throw (ProtocolException, Error)
{
	__BEGIN_TRY

	Assert(pCreature != NULL && pCreature->isPC());

	Coord_t cx = pCreature->getX();
	Coord_t cy = pCreature->getY();
	Player* pPlayer = pCreature->getPlayer();

	// Revealer 이펙트를 가져온다.
//	EffectRevealer* pEffectRevealer = NULL;
//	if ( pCreature->isFlag(Effect::EFFECT_CLASS_REVEALER) )
//	{
//		pEffectRevealer = dynamic_cast<EffectRevealer*>(pCreature->findEffect(Effect::EFFECT_CLASS_REVEALER));
//		Assert( pEffectRevealer != NULL );
//	}

	for (ZoneCoord_t ix = max(0, cx - maxViewportWidth - 1), endx = min(m_Width - 1, cx + maxViewportWidth + 1) ; ix <= endx ; ix++) 
	{
		for (ZoneCoord_t iy = max(0, cy - maxViewportUpperHeight - 1), endy = min(m_Height - 1, cy + maxViewportLowerHeight + 1) ; iy <= endy ; iy++) 
		{
			// darkness영역 조사.
			// 사실 pCreature는 당연히 slayer다.(updateInvisibleScan이므로..)
			if (pCreature->isSlayer())
			{
				const slist<Object*> & objectList = m_pTiles[ix][iy].getObjectList();
				slist<Object*>::const_iterator itr = objectList.begin();

				for (; itr != objectList.end() && (*itr)->getObjectPriority() <= OBJECT_PRIORITY_BURROWING_CREATURE ; itr++) 
				{
					if ((*itr)->getObjectClass() == Object::OBJECT_CLASS_CREATURE)
					{
						Creature* pPC = dynamic_cast<Creature*>(*itr);
						Assert(pPC != NULL);

						// 자기 자신일 경우 통과
						if ( pCreature == pPC ) continue;

						// 숨어있는 대상에 대해서..
						// SNIPING이나 INVISIBILITY상태일 경우.
						if (pPC->isFlag(Effect::EFFECT_CLASS_INVISIBILITY) && pCreature->getVisionState(ix,iy) >= IN_SIGHT)
						{
							// Detect Invisibility 이펙트가 있거나 뱀파이어면 볼 수 있다
							// Revealer 이펙트가 있을 경우 상대방을 볼 수 있는 레벨이라면
							if ( ( pCreature->isFlag(Effect::EFFECT_CLASS_DETECT_INVISIBILITY) || pCreature->isVampire() ) )
//								|| ( pEffectRevealer != NULL && pEffectRevealer->canSeeInvisibility( pPC ) ) )
							{
								if (pPC->isVampire())
								{
									Vampire* pVampire = dynamic_cast<Vampire*>(pPC);
									GCAddVampire gcAddVampire;

									makeGCAddVampire(&gcAddVampire, pVampire);
									pPlayer->sendPacket(&gcAddVampire);
								}
								else if (pPC->isMonster())
								{
									Monster* pMonster= dynamic_cast<Monster*>(pPC);
									//GCAddMonster gcAddMonster;
									//makeGCAddMonster(&gcAddMonster, pMonster);
									//pPlayer->sendPacket(&gcAddMonster);

									// by sigi
									Packet* pAddMonsterPacket = createMonsterAddPacket( pMonster, pCreature );

									if (pAddMonsterPacket!=NULL)
									{
										pPlayer->sendPacket(pAddMonsterPacket);

										delete pAddMonsterPacket;
									}
								}
							}
							else
							{
								GCDeleteObject gcDO;
								gcDO.setObjectID(pPC->getObjectID());
								pPlayer->sendPacket(&gcDO);
							}
						} 
						else if (pPC->isFlag(Effect::EFFECT_CLASS_SNIPING_MODE)) 
						{
							if ( (!pCreature->isVampire() && pCreature->isFlag(Effect::EFFECT_CLASS_DETECT_INVISIBILITY) ) )
//								|| ( pEffectRevealer != NULL && pEffectRevealer->canSeeSniping( pPC ) ) )
							{
								if (pPC->isSlayer())
								{
									Slayer* pSlayer = dynamic_cast<Slayer*>(pPC);
									
									GCAddSlayer gcAddSlayer;
									makeGCAddSlayer(&gcAddSlayer, pSlayer);
									pPlayer->sendPacket(&gcAddSlayer);
								}
								else 
								{
									throw Error("뱀파이어가 스나이핑 모드에 있다. 미쳐써~");
								}
							}
							else
							{
								GCDeleteObject gcDO;
								gcDO.setObjectID(pPC->getObjectID());
								pPlayer->sendPacket(&gcDO);
							}
						}
					}
				}
			}// darkness
		}
	}

	__END_CATCH
}

//--------------------------------------------------------------------------------
// update hidden scan
// detect hidden등의 효과가 사라진 경우..보이는 놈이 안보이게 될 경우
// pCreature에게 GCDeleteObject를 보내준다.
// 보고 있던 burrow creature를 delete한다. 또는 안보인는 넘이 보이게 될 경우등..
// ABCD
//--------------------------------------------------------------------------------
void Zone::updateHiddenScan(Creature* pCreature)
	throw(ProtocolException, Error)
{
	__BEGIN_TRY

	Assert(pCreature != NULL && pCreature->isPC());

	Coord_t cx = pCreature->getX();
	Coord_t cy = pCreature->getY();
	Player* pPlayer = pCreature->getPlayer();

	// Revealer 이펙트를 가져온다.
//	EffectRevealer* pEffectRevealer = NULL;
//	if ( pCreature->isFlag(Effect::EFFECT_CLASS_REVEALER) )
//	{
//		pEffectRevealer = dynamic_cast<EffectRevealer*>(pCreature->findEffect(Effect::EFFECT_CLASS_REVEALER));
//		Assert( pEffectRevealer != NULL );
//	}

	for (ZoneCoord_t ix = max(0, cx - maxViewportWidth - 1), endx = min(m_Width - 1, cx + maxViewportWidth + 1) ; ix <= endx ; ix++) 
	{
		for (ZoneCoord_t iy = max(0, cy - maxViewportUpperHeight - 1), endy = min(m_Height - 1, cy + maxViewportLowerHeight + 1) ; iy <= endy ; iy++) 
		{
			// darkness영역 조사.
			// 사실 pCreature는 당연히 slayer다.(updateHiddenScan이므로..)
			if (pCreature->isSlayer())
			{
				const slist<Object*> & objectList = m_pTiles[ix][iy].getObjectList();

				for (slist<Object*>::const_iterator itr = objectList.begin() ; itr != objectList.end() && (*itr)->getObjectPriority() <= OBJECT_PRIORITY_BURROWING_CREATURE ; itr++) 
				{

					if ((*itr)->getObjectClass() == Object::OBJECT_CLASS_CREATURE)
					{
						Creature* pPC = dynamic_cast<Creature*>(*itr);
						Assert(pPC != NULL);
						
						// 자기 자신일 경우 통과
						if ( pCreature == pPC ) continue;

						// 숨어있는 대상에 대해서..
						if (pPC->isFlag(Effect::EFFECT_CLASS_HIDE) && 
								pCreature->getVisionState(ix,iy) >= IN_SIGHT)
						{
							if ( pCreature->isFlag(Effect::EFFECT_CLASS_DETECT_HIDDEN) || pCreature->isVampire()  )
//								|| ( pEffectRevealer != NULL && pEffectRevealer->canSeeHide( pPC ) ) )
							{
								GCAddBurrowingCreature gcABC;
								gcABC.setObjectID(pPC->getObjectID());
								gcABC.setName(pPC->getName());
								gcABC.setX(ix);
								gcABC.setY(iy);
								pPlayer->sendPacket(&gcABC);
							}
							else
							{
								GCDeleteObject gcDO;
								gcDO.setObjectID(pPC->getObjectID());
								pPlayer->sendPacket(&gcDO);
							}
						}
					}
				}
			}// darkness
		}
	}

	__END_CATCH
}

//--------------------------------------------------------------------------------
// update mine scan
// detect mine등의 효과가 사라진 경우..보이는 mine이 안보이게 될 경우
// pCreature에게 GCDeleteObject를 보내준다.
//--------------------------------------------------------------------------------
void Zone::updateMineScan(Creature* pCreature)
	throw(ProtocolException, Error)
{
	__BEGIN_TRY

	Assert(pCreature != NULL && pCreature->isPC());

	Coord_t cx = pCreature->getX();
	Coord_t cy = pCreature->getY();
	Player* pPlayer = pCreature->getPlayer();

	for (ZoneCoord_t ix = max(0, cx - maxViewportWidth - 1), endx = min(m_Width - 1, cx + maxViewportWidth + 1) ; ix <= endx ; ix++) 
	{
		for (ZoneCoord_t iy = max(0, cy - maxViewportUpperHeight - 1), endy = min(m_Height - 1, cy + maxViewportLowerHeight + 1) ; iy <= endy ; iy++) 
		{
			// 사실 pCreature는 당연히 slayer다.(updateMineScan이므로..)
			if (pCreature->isSlayer())
			{
				Item* pItem = m_pTiles[ix][iy].getItem();
				if (pItem)
				{
					if (pItem->getItemClass() == Item::ITEM_CLASS_MINE && pItem->isFlag(Effect::EFFECT_CLASS_INSTALL))
					{
						if (pCreature->isFlag(Effect::EFFECT_CLASS_REVEALER) )
						{
							
							GCAddInstalledMineToZone gcAddMine;
							gcAddMine.setObjectID(pItem->getObjectID());
							gcAddMine.setX(ix);
							gcAddMine.setY(iy);
							gcAddMine.setItemClass(pItem->getItemClass());
							gcAddMine.setItemType(pItem->getItemType());
							gcAddMine.setOptionType(pItem->getOptionType());
							gcAddMine.setDurability(pItem->getDurability());

							pPlayer->sendPacket(&gcAddMine);
						} else {
							GCDeleteObject gcDO;
							gcDO.setObjectID(pItem->getObjectID());
							pPlayer->sendPacket(&gcDO);
						}
					}
				}
			}// darkness
		}
	}

	__END_CATCH
}


//--------------------------------------------------------------------------------
// add Creature
// 크리처가 존에 최초로 들어갈 때, 크리처 주변의 PC들에게 새 크리처의 출현을 알려준다.
//--------------------------------------------------------------------------------
void Zone::addCreature(Creature* pCreature, ZoneCoord_t cx, ZoneCoord_t cy, Dir_t dir)
	throw(EmptyTileNotExistException, Error)
{
	__BEGIN_TRY

	TPOINT pt = findSuitablePosition(this, cx, cy, pCreature->getMoveMode());

	// 찾은 경우 체크
	if (pt.x != -1) 
	{
		//--------------------------------------------------------------------------------
		// OID 를 할당받는다.
		//--------------------------------------------------------------------------------
		m_ObjectRegistry.registerObject(pCreature);

		//--------------------------------------------------------------------------------
		// 적절한 타일을 찾았으면, 크리처를 크리처매니저와 타일에 각각 집어넣는다.
		// Monster 일 경우, MonsterManager에 추가하며, NPC 일 경우, NPCManager 에 추가한다.
		//--------------------------------------------------------------------------------
		if (pCreature->isMonster())
		{

//#ifdef __XMAS_EVENT_CODE__
			Monster* pMonster = dynamic_cast<Monster*>(pCreature);
			switch (pMonster->getMonsterType())
			{
				case 358:
				case 359:
				case 360:
				case 361:
					m_pEventMonsterManager->addCreature(pCreature);
					break;

				case 371:
				case 372:
				case 373:
				case 374:
				case 375:
				case 376:
					m_pCombatMonsterManager->addCreature(pCreature); // 362는 전투용 몬스터로 정의함, 김경석
					break;

				default:
					m_pMonsterManager->addCreature(pCreature);
					break;
			}
//#else
//			m_pMonsterManager->addCreature(pCreature);
/*
#endif
*/
		}
		else if (pCreature->isNPC())
		{
			m_pNPCManager->addCreature(pCreature);
		}

		//cout << "타일에 몬스터 추가하기" << endl;
	   	m_pTiles[pt.x][pt.y].addCreature(pCreature, false);
	
		//--------------------------------------------------------------------------------
		// 크리처의 좌표를 지정한다.
		//--------------------------------------------------------------------------------
		pCreature->setXYDir(pt.x, pt.y, dir);
		pCreature->setZone(this);
		
		//scanPC(pCreature);

		//--------------------------------------------------------------------------------
		// 주변의 PC들에게 알릴 GCAddNPC or GCAddMonster 패킷을 생성한다.
		//--------------------------------------------------------------------------------
		//cout << "주변의 PC들에게 알릴 패킷 만들기" << endl;
		Creature::CreatureClass CClass = pCreature->getCreatureClass();

		if (CClass == Creature::CREATURE_CLASS_NPC)
		{
			NPC* pNPC = dynamic_cast<NPC*>(pCreature);
			GCAddNPC gcAddNPC;
			makeGCAddNPC(&gcAddNPC, pNPC);
			broadcastPacket(pt.x, pt.y, &gcAddNPC);
		}
		else if (CClass == Creature::CREATURE_CLASS_MONSTER)
		{
			//cout << "몬스터용 패킷 만들기" << endl;
			Monster* pMonster = dynamic_cast<Monster*>(pCreature);

			//GCAddMonster gcAddMonster;
			//makeGCAddMonster(&gcAddMonster, pMonster);
			//broadcastPacket(pt.x, pt.y, &gcAddMonster);

			// zone에 처음 들어갈때도 여러가지 상태가 있다.. by sigi
			Packet* pAddMonsterPacket = createMonsterAddPacket( pMonster, NULL );

			if (pAddMonsterPacket!=NULL)
			{
				//cout << "몬스터용 패킷이 만들어졌으면" << endl;
				bool isMonsterHide = pMonster->isFlag(Effect::EFFECT_CLASS_HIDE);
				bool isMonsterInvisibility = pMonster->isFlag(Effect::EFFECT_CLASS_INVISIBILITY);

				//broadcastPacket(pt.x, pt.y, pAddMonsterPacket);
				ZoneCoord_t ix = 0;
				ZoneCoord_t iy = 0;
				ZoneCoord_t endx = 0;
				ZoneCoord_t endy = 0;

				//////////////////////////////////////////////////////////////////////////////
				// 루프 변수 초기화..
				//
				// Plus 변수가 참일 경우 Range 만큼 더 보내 준다..
				// 광역 마법의 결과를 효과적으로 보여주기 위함이다.
				//
				// *NOTE
				// - 최적화를 한다면 VisionInfo에 PLUS_SIGHT라는 변수를 추가하여 연산
				//////////////////////////////////////////////////////////////////////////////
				int Range = 0;
				endx = min(m_Width - 1, cx + maxViewportWidth + 1 + Range);
				endy = min(m_Height - 1, cy + maxViewportLowerHeight  + 1 + Range);

				for (ix =  max(0, cx - maxViewportWidth - 1 - Range); ix <= endx ; ix++) 
				{
					for (iy = max(0, cy - maxViewportUpperHeight - 1 -  Range); iy <= endy ; iy++) 
					{
						// 타일에 크리처가 있는 경우에만
						if (m_pTiles[ix][iy].hasCreature()) 
						{
							//cout << ix << "," << iy << "에 Creature 존재" << endl;
							const slist<Object*> & objectList = m_pTiles[ix][iy].getObjectList();
							slist<Object*>::const_iterator itr = objectList.begin();

							for (; itr != objectList.end() && (*itr)->getObjectPriority() <= OBJECT_PRIORITY_BURROWING_CREATURE; itr++) 
							{
								Creature* pCreature = dynamic_cast<Creature*>(*itr);
								Assert(pCreature != NULL);

								//cout << pCreature->toString() << endl;
								// PC이면서, creatureList에 소속되지도 않으면서, (x,y)를 볼 수 있는 경우
								if (pCreature->isPC()) 
								{
									// Revealer 이펙트가 있다면 이펙트를 가져온다.
//									EffectRevealer* pEffectRevealer = NULL;
//									if ( pCreature->isFlag( Effect::EFFECT_CLASS_REVEALER ) )
//									{
//										pEffectRevealer = dynamic_cast<EffectRevealer*>(pCreature->findEffect(Effect::EFFECT_CLASS_REVEALER));
//										Assert( pEffectRevealer != NULL );
//									}

									if (pCreature->getVisionState(cx,cy) >= IN_SIGHT
										&& (pCreature->isVampire() 
											|| (!isMonsterHide || pCreature->isFlag(Effect::EFFECT_CLASS_DETECT_HIDDEN))
//												|| ( pEffectRevealer != NULL && pEffectRevealer->canSeeHide( pMonster ) ) )
											&& (!isMonsterInvisibility || pCreature->isFlag(Effect::EFFECT_CLASS_DETECT_INVISIBILITY))
//												|| ( pEffectRevealer != NULL && pEffectRevealer->canSeeInvisibility( pMonster ) ) )
											)
										)
									{
										pCreature->getPlayer()->sendPacket(pAddMonsterPacket);
									}
								} // if

							} // for
						}//if
					}//for
				}//for


				delete pAddMonsterPacket;
			}
		}
		else
		{
			throw Error("invalid creature type");
		}
	} 
	else 
	{
		throw EmptyTileNotExistException("too many creature in this zone.. or too unlucky");
	}

	__END_CATCH
}


//--------------------------------------------------------------------------------
// 특정 위치에 아이템을 떨어뜨린다.
// Zone ::addItem()
// 7x7 영역을 검사해서 빈칸이 존재하면 떨어뜨린다. 문제는 재수없는 경우 빈칸이 
// 존재하지 않을 경우인데.. 이때 예외를 던짐으로써 그 처리를 상위에게 맡기면
// 될 듯...
//--------------------------------------------------------------------------------
TPOINT Zone::addItem(Item* pItem, ZoneCoord_t cx, ZoneCoord_t cy, bool bAllowCreature)
	throw(EmptyTileNotExistException, Error)
{
	__BEGIN_TRY

	__BEGIN_DEBUG

	Item::ItemClass IClass = pItem->getItemClass();
	TPOINT          pt     = findSuitablePositionForItem(this, cx, cy, bAllowCreature);
	
	// 놓을 위치를 찾아낸 경우
	if (pt.x != -1) 
	{ 
		m_pTiles[pt.x][pt.y].addItem(pItem);
		addToItemList(pItem);
			   	
		if (IClass == Item::ITEM_CLASS_CORPSE) 
		{
			ItemType_t itemType = pItem->getItemType();

			Turn_t DelayTime = 0;
			if (itemType == SLAYER_CORPSE)
			{
				SlayerCorpse* pSlayerCorpse = dynamic_cast<SlayerCorpse*>(pItem);
				pSlayerCorpse->setXY(pt.x, pt.y);

				GCAddSlayerCorpse gcAddSlayerCorpse;
				makeGCAddSlayerCorpse(&gcAddSlayerCorpse, pSlayerCorpse);
				broadcastPacket(pt.x, pt.y, &gcAddSlayerCorpse);
				DelayTime = 6000;
			}
			else if (itemType == VAMPIRE_CORPSE)
			{
				VampireCorpse* pVampireCorpse = dynamic_cast<VampireCorpse*>(pItem);
				pVampireCorpse->setXY(pt.x, pt.y);

				GCAddVampireCorpse gcAddVampireCorpse;
				makeGCAddVampireCorpse(&gcAddVampireCorpse, pVampireCorpse);
				broadcastPacket(pt.x, pt.y, &gcAddVampireCorpse);
				DelayTime = 6000;
			}
			else if (itemType == NPC_CORPSE)
			{
				Assert(false);
			}
			else if (itemType == MONSTER_CORPSE)
			{
				MonsterCorpse* pMonsterCorpse = dynamic_cast<MonsterCorpse*>(pItem);
				GCAddMonsterCorpse gcAddMonsterCorpse;
				makeGCAddMonsterCorpse(&gcAddMonsterCorpse, pMonsterCorpse, pt.x, pt.y);
				broadcastPacket(pt.x, pt.y, &gcAddMonsterCorpse);
				DelayTime = 600;
			}
			else
			{
				Assert(false);
			}

			// 아이템이 들어가있지 않은 시체라면 딜레이 시간을 줄인다.
			Corpse* pCorpse = dynamic_cast<Corpse*>(pItem);
			if (pCorpse->getTreasureCount() == 0)
			{
				DelayTime = DelayTime/10;
			}

			// Relic인 경우에는 시간의 지연에 따라 아이템이 사라지지 않는다.
			if (!pCorpse->getRelic())
			{
				// 바닥에 떨어지는 아이템은 일정 시간이 지나면 사라지게 된다.
				EffectDecayCorpse* pEffectDecayCorpse = new EffectDecayCorpse(this, pt.x, pt.y, (Corpse*)pItem, DelayTime);
				pEffectDecayCorpse->setNextTime(999999);
				m_ObjectRegistry.registerObject(pEffectDecayCorpse);
				addEffect(pEffectDecayCorpse);
			}
			else
			{
				cout << "Relic인 경우에는 시체가 사라지지 않습니다" << endl;
			}
		} 
		else
		{
			GCDropItemToZone gcDropItemToZone;
			makeGCDropItemToZone(&gcDropItemToZone, pItem, pt.x, pt.y);

//			if ( !pItem->isFlag(Effect::EFFECT_CLASS_INSTALL) ) {
				broadcastPacket(pt.x, pt.y, &gcDropItemToZone);
//			}

			// 모터사이클은 시간이 지나도 사라지지 않는다.
			if (IClass == Item::ITEM_CLASS_MOTORCYCLE)
			{
				// transport인 경우를 대비해서 체크해제해야한다.
				MotorcycleBox* pMotorcycleBox = g_pParkingCenter->getMotorcycleBox( pItem->getItemID() );

				if (pMotorcycleBox!=NULL)
				{
					pMotorcycleBox->setTransport( false );
					pMotorcycleBox->setX( pt.x );
					pMotorcycleBox->setY( pt.y );
				}
			}
			else
			{
				// 바닥에 떨어지는 아이템은 일정 시간이 지나면 사라지게 된다.
				EffectDecayItem* pEffectDecayItem = new EffectDecayItem(this, pt.x, pt.y, (Item*)pItem, 6000);
				pEffectDecayItem->setNextTime(999999);
				m_ObjectRegistry.registerObject(pEffectDecayItem);
				addEffect(pEffectDecayItem);
			}
		}

		return pt;
	} 
	else 
	{
		//throw InvalidProtocolException("too many item in this zone.. or too unlucky");
		//pItem->destroy();
		//Delete pItem;

		TPOINT pt_error;
		pt_error.x = -1;
		pt_error.y = -1;
		return pt_error;
	}

	return pt;

	__END_DEBUG
	__END_CATCH
}

//--------------------------------------------------------------------------------
//--------------------------------------------------------------------------------
void Zone::addEffect(Effect* pEffect)
	throw(Error)
{
	__BEGIN_TRY

	Assert(pEffect != NULL);

	m_pEffectManager->addEffect(pEffect);

	__END_CATCH
}

void Zone::deleteEffect(ObjectID_t id) 
	throw(Error)
{
	__BEGIN_TRY

	m_pEffectManager->deleteEffect(id);

	__END_CATCH
}

//--------------------------------------------------------------------------------
//--------------------------------------------------------------------------------
void Zone::addEffect_LOCKING(Effect* pEffect)
	throw(Error)
{
	__BEGIN_TRY

	Assert(pEffect != NULL);

	__ENTER_CRITICAL_SECTION(m_MutexEffect)

	m_pLockedEffectManager->addEffect(pEffect);

	__LEAVE_CRITICAL_SECTION(m_MutexEffect)

	__END_CATCH
}

void Zone::deleteEffect_LOCKING(ObjectID_t id) 
	throw(Error)
{
	__BEGIN_TRY

	__ENTER_CRITICAL_SECTION(m_MutexEffect)

	m_pLockedEffectManager->deleteEffect(id);

	__LEAVE_CRITICAL_SECTION(m_MutexEffect)

	__END_CATCH
}




//--------------------------------------------------------------------------------
// Delete PC from PC Manager (only do this)
//--------------------------------------------------------------------------------
void Zone::deletePC(Creature* pCreature) 
	throw()//NoSuchElementException, Error)
{
	__BEGIN_TRY

	Assert(pCreature != NULL);
	m_pPCManager->deleteCreature(pCreature->getObjectID());

	__END_CATCH
}

//--------------------------------------------------------------------------------
// Delete Queue PC
//--------------------------------------------------------------------------------
void Zone::deleteQueuePC(Creature* pCreature) 
	throw(NoSuchElementException, Error)
{
	__BEGIN_TRY

	__ENTER_CRITICAL_SECTION(m_Mutex)

	Assert(pCreature != NULL);

	list<Creature*>::iterator itr = find_if (m_PCListQueue.begin(), m_PCListQueue.end(), isSameCreature(pCreature));

	if (itr != m_PCListQueue.end()) 
	{

		m_PCListQueue.erase(itr);

	}

	__LEAVE_CRITICAL_SECTION(m_Mutex)

	__END_CATCH
}

//--------------------------------------------------------------------------------
// Add PC to PC Manager (only do this)
//--------------------------------------------------------------------------------
void Zone::addPC(Creature* pCreature) 
	throw(Error)
{
	__BEGIN_TRY

	Assert(pCreature != NULL);
	m_pPCManager->addCreature(pCreature);

	__END_CATCH
}


//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
void Zone::deleteCreature(Creature* pCreature, ZoneCoord_t x, ZoneCoord_t y)
	throw(NoSuchElementException, Error)
{
	__BEGIN_TRY

	try 
	{
		Assert(pCreature->getX() == x && pCreature->getY() == y);

		// 해당되는 CreatureManager 에서 크리처를 삭제한다.
		if (pCreature->isPC())
		{
			m_pPCManager->deleteCreature(pCreature->getObjectID());

			// 파티 초대중이라면 PartyInviteInfo를 삭제해준다.
			m_pPartyInviteInfoManager->cancelInvite(pCreature);

			// 파티에 가입되어 있었다면 로컬 파티에서 삭제해 준다.
			uint PartyID = pCreature->getPartyID();
			if (PartyID != 0)
			{
				m_pLocalPartyManager->deletePartyMember(PartyID, pCreature);
			}

			// 트레이드 중이었다면 트레이드 관련 정보를 삭제해준다.
			TradeInfo* pInfo = m_pTradeManager->getTradeInfo(pCreature->getName());
			if (pInfo != NULL)
			{
				m_pTradeManager->cancelTrade(pCreature);
			}
		}
		else if (pCreature->isMonster())
		{

//#ifdef __XMAS_EVENT_CODE__
			Monster* pMonster = dynamic_cast<Monster*>(pCreature);
			switch (pMonster->getMonsterType())
			{
				case 358:
				case 359:
				case 360:
				case 361:
					m_pEventMonsterManager->deleteCreature(pCreature->getObjectID());
					break;

				case 371:
				case 372:
				case 373:
				case 374:
				case 375:
				case 376:
					m_pCombatMonsterManager->deleteCreature(pCreature->getObjectID());
					break;

				default:
					m_pMonsterManager->deleteCreature(pCreature->getObjectID());
					break;
			}
//#else
//			m_pMonsterManager->deleteCreature(pCreature->getObjectID());
/*
#endif
*/
		}
		else if (pCreature->isNPC())
		{
			m_pNPCManager->deleteCreature(pCreature->getObjectID());
		}

		// 타일에서 크리처를 삭제한다.
		getTile(x, y).deleteCreature(pCreature->getObjectID());

		// 주변의 PC들에게 크리처가 사라졌다는 사실을 브로드캐스트한다.
		GCDeleteObject gcDeleteObject(pCreature->getObjectID());
		broadcastPacket(x, y, &gcDeleteObject, pCreature);
	} 
	catch (Throwable & t) 
	{
		cerr << t.toString() << endl;
	}

	__END_CATCH
}


//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
void Zone::deleteObject(Object* pObject, ZoneCoord_t x, ZoneCoord_t y)
	throw(NoSuchElementException, Error)
{
	__BEGIN_TRY

	//--------------------------------------------------
	// 존에서 객체를 삭제한다.
	//--------------------------------------------------
	getTile(x, y).deleteObject(pObject->getObjectID());

	//--------------------------------------------------
	// 주변의 PC들에게 객체가 사라졌다는 사실을 브로드캐스트한다.
	//--------------------------------------------------
	GCDeleteObject gcDeleteObject(pObject->getObjectID());

	broadcastPacket(x, y, &gcDeleteObject);

	__END_CATCH
}

//--------------------------------------------------------------------------------
//
//--------------------------------------------------------------------------------
void Zone::deleteItem(Object* pObject, ZoneCoord_t x, ZoneCoord_t y)
	throw(NoSuchElementException, Error)
{
	__BEGIN_TRY

	deleteFromItemList(pObject->getObjectID());

	//--------------------------------------------------
	// 존에서 객체를 삭제한다.
	//--------------------------------------------------
	getTile(x, y).deleteItem();

	//--------------------------------------------------
	// 주변의 PC들에게 객체가 사라졌다는 사실을 브로드캐스트한다.
	//--------------------------------------------------
//	GCDeleteObject gcDeleteObject(pObject->getObjectID());

//	broadcastPacket(x, y, &gcDeleteObject);

	__END_CATCH
}


//--------------------------------------------------------------------------------
//
// broadcast packet
//
// 특정 존에 존재하는, owner를 제외한 모든 PC 에게 지정된 패킷을 전송한다.
//
//--------------------------------------------------------------------------------
void Zone::broadcastPacket(Packet* pPacket, Creature* owner)
	throw(ProtocolException, Error)
{
	__BEGIN_TRY

	m_pPCManager->broadcastPacket(pPacket, owner);

	__END_CATCH
}

void Zone::broadcastDarkLightPacket(Packet* pPacket1, Packet* pPacket2, Creature* owner)
	throw(ProtocolException, Error)
{
	__BEGIN_TRY

	m_pPCManager->broadcastDarkLightPacket(pPacket1,  pPacket2, owner);

	__END_CATCH
}

//--------------------------------------------------------------------
//
// 채팅을 브로드캐스팅 하는 함수이다. 서로다른 종족간에는 볼 수 없다.-
// 뱀파이어가 보내는 패킷은 isVampire가 True로 날아온다.
//
//--------------------------------------------------------------------
void Zone::broadcastSayPacket(ZoneCoord_t cx, ZoneCoord_t cy, Packet* pPacket, Creature* owner, bool isVampire)
	throw(ProtocolException, Error)
{
	__BEGIN_TRY

	ZoneCoord_t ix = 0;
	ZoneCoord_t iy = 0;
	ZoneCoord_t endx = 0;
	ZoneCoord_t endy = 0;

	//-------------------------------------------------------------------
	// 루프 변수 초기화..
	//
	// Plus 변수가 참일 경우 Range 만큼 더 보내 준다..
	// 광역 마법의 결과를 효과적으로 보여주기 위함이다.
	//
	// *NOTE
	// - 최적화를 한다면 VisionInfo에 PLUS_SIGHT라는 변수를 추가하여 연산
	//-------------------------------------------------------------------
	endx = min(m_Width - 1, cx + maxViewportWidth + 1);
	endy = min(m_Height - 1, cy + maxViewportLowerHeight  + 1);

	for (ix =  max(0, cx - maxViewportWidth - 1); ix <= endx ; ix++) 
	{
		for (iy = max(0, cy - maxViewportUpperHeight - 1); iy <= endy ; iy++) 
		{
			Tile& rTile = m_pTiles[ix][iy];	// by sigi. 2002.5.8

			// 타일에 크리처가 있는 경우에만
			if (rTile.hasCreature()) 
			{
				const slist<Object*> & objectList = rTile.getObjectList();

				for (slist<Object*>::const_iterator itr = objectList.begin() ; 
					itr != objectList.end() && (*itr)->getObjectPriority() <= OBJECT_PRIORITY_BURROWING_CREATURE; 
					itr++) 
				{
					Creature* pCreature = dynamic_cast<Creature*>(*itr);		
					Assert(pCreature != NULL);

					// PC이면서, owner가 아니면서, (x,y)를 볼 수 있는 경우
					if ((pCreature->isPC() && pCreature != owner && pCreature->getVisionState(cx,cy) >= IN_SIGHT) || (pCreature->isPC() && pCreature != owner))
					{
						// 숨어 있는 넘이 뭔 짓을 하면 안보여 주는데.. 딴짓 하면 Unborrowing 시켜야 되는디.
						// 뱀파이어가 보내는 패킷은 isVampire가 True로 날아온다.
						if (owner != NULL) 
						{
							// Creature 에서 Revealer 이펙트가 있으면 이펙트를 가져온다.
//							EffectRevealer* pEffectRevealer = NULL;
//							if ( pCreature->isFlag( Effect::EFFECT_CLASS_REVEALER ) )
//							{
//								pEffectRevealer = dynamic_cast<EffectRevealer*>(pCreature->findEffect( Effect::EFFECT_CLASS_REVEALER ) );
//								Assert( pEffectRevealer != NULL );
//							}

							if ((!owner->isFlag(Effect::EFFECT_CLASS_HIDE) || pCreature->isVampire() || pCreature->isFlag(Effect::EFFECT_CLASS_DETECT_HIDDEN) )// || ( pEffectRevealer != NULL && pEffectRevealer->canSeeHide(owner) ) )
								&& (!owner->isFlag(Effect::EFFECT_CLASS_INVISIBILITY) || pCreature->isVampire() || pCreature->isFlag(Effect::EFFECT_CLASS_DETECT_INVISIBILITY) ) // || ( pEffectRevealer != NULL && pEffectRevealer->canSeeInvisibility(owner) ) )
								&& (!owner->isFlag(Effect::EFFECT_CLASS_SNIPING_MODE) || pCreature->isFlag(Effect::EFFECT_CLASS_DETECT_INVISIBILITY) ) // || ( pEffectRevealer != NULL && pEffectRevealer->canSeeSniping(owner) ) )
								&& ((isVampire && pCreature->isVampire()) || (!isVampire && pCreature->isSlayer()))
								)
							{
								pCreature->getPlayer()->sendPacket(pPacket);
							}
						} 
						else 
						{
							pCreature->getPlayer()->sendPacket(pPacket);
						}
					}
				}
			}
		}
	}

	__END_CATCH
}

//--------------------------------------------------------------------------------
//
// broadcast packet
//
// (x,y) 의 사건을 볼 수 있는, owner를 제외한 모든 PC 들에게 패킷을 브로드캐스트한다.
//
// *CAUTION*
//
// unsigned char 를 ZoneCoord_t 로 사용할 때, overflow 및 underflow 를 주의할 것
//
//--------------------------------------------------------------------------------
void Zone::broadcastPacket(ZoneCoord_t cx, ZoneCoord_t cy, Packet* pPacket, Creature* owner, bool Plus, Range_t Range)
	throw(ProtocolException, Error)
{
	__BEGIN_TRY

	ZoneCoord_t ix = 0;
	ZoneCoord_t iy = 0;
	ZoneCoord_t endx = 0;
	ZoneCoord_t endy = 0;

	//-------------------------------------------------------------------
	// 루프 변수 초기화..
	//
	// Plus 변수가 참일 경우 Range 만큼 더 보내 준다..
	// 광역 마법의 결과를 효과적으로 보여주기 위함이다.
	//
	// *NOTE
	// - 최적화를 한다면 VisionInfo에 PLUS_SIGHT라는 변수를 추가하여 연산
	//-------------------------------------------------------------------
	endx = min(m_Width - 1, cx + maxViewportWidth + 1 + Range);
	endy = min(m_Height - 1, cy + maxViewportLowerHeight  + 1 + Range);

	for (ix =  max(0, cx - maxViewportWidth - 1 - Range); ix <= endx ; ix++) 
	{
		for (iy = max(0, cy - maxViewportUpperHeight - 1 -  Range); iy <= endy ; iy++) 
		{
			Tile& rTile = m_pTiles[ix][iy];	// by sigi.2002.5.8

			// 타일에 크리처가 있는 경우에만
			if (rTile.hasCreature()) 
			{
				const slist<Object*> & objectList = rTile.getObjectList();

				for (slist<Object*>::const_iterator itr = objectList.begin() ; 
					itr != objectList.end() && (*itr)->getObjectPriority() <= OBJECT_PRIORITY_BURROWING_CREATURE; 
					itr++) 
				{
					Creature* pCreature = dynamic_cast<Creature*>(*itr);		
					Assert(pCreature != NULL);

					// PC이면서, owner가 아니면서, (x,y)를 볼 수 있는 경우
					//if ((pCreature->isPC() && pCreature != owner && pCreature->getVisionState(cx,cy) >= IN_SIGHT)
					 // ||(pCreature->isPC() && pCreature != owner && Plus))

					// by sigi. 2002.5.14
					if (pCreature->isPC() && pCreature != owner 
						&& (pCreature->getVisionState(cx,cy) >= IN_SIGHT || Plus))
					{
						// 숨어 있는 넘이 뭔 짓을 하면 안보여 주는데.. 딴짓 하면 Unborrowing 시켜야 되는디.
						if (owner != NULL) 
						{
							// Creature 가 Revealer 이펙트를 가지고 있으면 이펙트를 가져온다.
//							EffectRevealer* pEffectRevealer = NULL;
//							if ( pCreature->isFlag( Effect::EFFECT_CLASS_REVEALER ) )
//							{
//								pEffectRevealer = dynamic_cast<EffectRevealer*>(pCreature->findEffect( Effect::EFFECT_CLASS_REVEALER ) );
//								Assert( pEffectRevealer != NULL );
//							}

							if ((!owner->isFlag(Effect::EFFECT_CLASS_HIDE) || pCreature->isVampire() || pCreature->isFlag(Effect::EFFECT_CLASS_DETECT_HIDDEN) ) // || ( pEffectRevealer != NULL && pEffectRevealer->canSeeHide( owner ) ) )
								&& (!owner->isFlag(Effect::EFFECT_CLASS_INVISIBILITY) || pCreature->isVampire() || pCreature->isFlag(Effect::EFFECT_CLASS_DETECT_INVISIBILITY) ) // || ( pEffectRevealer != NULL && pEffectRevealer->canSeeInvisibility( owner ) ) )
								&& (!owner->isFlag(Effect::EFFECT_CLASS_SNIPING_MODE) || pCreature->isFlag(Effect::EFFECT_CLASS_DETECT_INVISIBILITY) ) // || ( pEffectRevealer != NULL && pEffectRevealer->canSeeSniping( owner ) ) )
							)
							{
								pCreature->getPlayer()->sendPacket(pPacket);
							}
						} 
						else 
						{
							pCreature->getPlayer()->sendPacket(pPacket);
						}
					}
				}
			}
		}
	}

	__END_CATCH
}

//--------------------------------------------------------------------------------
//
// update scan
//
// 제자리에서 sight가 변했을 경우. Add&Delete packet을 보낸다.
//
//--------------------------------------------------------------------------------
void Zone::updateScan (Creature* pPC, Sight_t oldSight, Sight_t newSight)
	throw (ProtocolException, Error)
{
	__BEGIN_TRY

	if (pPC == NULL || pPC->isPC() == false) return;
	//Assert(pPC != NULL);
	//Assert(pPC->isPC());

	Coord_t cx = pPC->getX(), cy = pPC->getY();
	
	Player* pPlayer = pPC->getPlayer();
	Assert(pPlayer);

	for (ZoneCoord_t ix = max(0, cx - maxViewportWidth - 1), endx = min(m_Width - 1, cx + maxViewportWidth + 1) ; ix <= endx ; ix++) 
	{
		for (ZoneCoord_t iy = max(0, cy - maxViewportUpperHeight - 1), endy = min(m_Height - 1, cy + maxViewportLowerHeight + 1) ; iy <= endy ; iy++) 
		{
			VisionState oldVS = pPC->getVisionState(ix, iy, oldSight); 
			VisionState newVS = pPC->getVisionState(ix, iy, newSight);

			const slist<Object*> & objectList = m_pTiles[ix][iy].getObjectList();

			for (slist<Object*>::const_iterator itr = objectList.begin() ; itr != objectList.end() ; itr++) 
			{

				Assert(*itr != NULL);

				// 안보였다가 보이는 경우..
				// ADD~~
				if (oldVS == OUT_OF_SIGHT && newVS != OUT_OF_SIGHT)
				{
					//--------------------------------------------------------------------------------
					// 각 객체의 OBJECT CLASS에 따라서 적합한 GCAddXXX 패킷을 만들어서
					// owner 에게 전송한다. 
					// *NOTES*
					// 가장 출현 확률이 높은 객체 CLASS 가 case 앞부분에 나와야 한다.
					//--------------------------------------------------------------------------------
					switch ((*itr)->getObjectClass()) 
					{
						////////////////////////////////////////////////////////////
						////////////////////////////////////////////////////////////
						case Object::OBJECT_CLASS_CREATURE:
							{
								//--------------------------------------------------------------------------------
								// PC의 경우 pPacket을 전송해야 하며, !PC인 경우에는 전송할 필요가 없다.
								// 또한 모든 크리처의 정보를 owner에게 전송해야 한다.
								//--------------------------------------------------------------------------------
								Creature* pCreature = dynamic_cast<Creature*>(*itr);
								Assert(pCreature != NULL);

								// 자기 자신의 정보는 받을 필요가 없다.
								if (pCreature == pPC) continue;

								switch (pCreature->getCreatureClass()) 
								{
									case Creature::CREATURE_CLASS_MONSTER :
										{
											Monster* pMonster = dynamic_cast<Monster*>(pCreature);

											// by sigi
											Packet* pAddMonsterPacket = createMonsterAddPacket( pMonster, pPC );

											if (pAddMonsterPacket!=NULL)
											{
												pPlayer->sendPacket( pAddMonsterPacket );

												delete pAddMonsterPacket;
											}
										}
										break;
			

									case Creature::CREATURE_CLASS_SLAYER:
										{
											// PC 가 Revealer 이펙트를 가지고 있다면 이펙트를 가져온다.
//											EffectRevealer* pEffectRevealer = NULL;
//											if ( pPC->isFlag( Effect::EFFECT_CLASS_REVEALER ) )
//											{
//												pEffectRevealer = dynamic_cast<EffectRevealer*>(pPC->findEffect( Effect::EFFECT_CLASS_REVEALER ) );
//												Assert( pEffectRevealer );
//											}
											
											if (!pCreature->isFlag(Effect::EFFECT_CLASS_SNIPING_MODE)
												|| pPC->isFlag(Effect::EFFECT_CLASS_DETECT_INVISIBILITY) )
//												|| ( pEffectRevealer != NULL && pEffectRevealer->canSeeSniping(pCreature) ) )
											{
												Slayer* pSlayer = dynamic_cast<Slayer*>(pCreature);
												GCAddSlayer gcAddSlayer;
												makeGCAddSlayer(&gcAddSlayer, pSlayer);
												pPlayer->sendPacket(&gcAddSlayer);
											}
										}
										break;
			
									case Creature::CREATURE_CLASS_VAMPIRE :
										{
											// PC 가 Revealer 이펙트를 가지고 있다면 이펙트를 가져온다.
//											EffectRevealer* pEffectRevealer = NULL;
//											if ( pPC->isFlag( Effect::EFFECT_CLASS_REVEALER ) )
//											{
//												pEffectRevealer = dynamic_cast<EffectRevealer*>(pPC->findEffect( Effect::EFFECT_CLASS_REVEALER ) );
//												Assert( pEffectRevealer );
//											}

											//
											// hide와 invisibility는 동시에 사용될 수 없는다는 가정하에..
											// 
											if (pCreature->isFlag(Effect::EFFECT_CLASS_HIDE)) 
											{
												if (pPC->isVampire() || pPC->isFlag(Effect::EFFECT_CLASS_DETECT_HIDDEN) )
//													|| ( pEffectRevealer != NULL && pEffectRevealer->canSeeHide( pCreature ) ) ) 
												{
													GCAddBurrowingCreature gcABC;
													gcABC.setObjectID(pCreature->getObjectID());
													gcABC.setName(pCreature->getName());
													gcABC.setX(ix);
													gcABC.setY(iy);

													pPlayer->sendPacket(&gcABC);
												}
											} 
											else 
											{
												if (!pCreature->isFlag(Effect::EFFECT_CLASS_INVISIBILITY))
												{
													Vampire* pVampire = dynamic_cast<Vampire*>(pCreature);
													GCAddVampire gcAddVampire;
													makeGCAddVampire(&gcAddVampire, pVampire);
													pPlayer->sendPacket(&gcAddVampire);
												}
												// pCreature는 invisibility상태..
												else if (pPC->isVampire() || pPC->isFlag(Effect::EFFECT_CLASS_DETECT_INVISIBILITY) )
//														|| ( pEffectRevealer != NULL && pEffectRevealer->canSeeInvisibility( pCreature ) ) )
												{
													// FIXME
													// 설정에따라서 어떻게 보일지 결정된 후..
													//
													Vampire* pVampire = dynamic_cast<Vampire*>(pCreature);
													GCAddVampire gcAddVampire;
													makeGCAddVampire(&gcAddVampire, pVampire);
													pPlayer->sendPacket(&gcAddVampire);
												}
											}
				
										}
										break;
			
									case Creature::CREATURE_CLASS_NPC :
										{
											NPC* pNPC = dynamic_cast<NPC*>(pCreature);
											GCAddNPC gcAddNPC;
											makeGCAddNPC(&gcAddNPC, pNPC);
											pPlayer->sendPacket(&gcAddNPC);
										}
										break;
			
									default :
										throw Error("invalid creature class");
		
								}//switch (pCreature->getCreatureClass())
							}//case Object::OBJECT_CLASS_CREATURE :
							break;

						//--------------------------------------------------------------------------------
						// 타일 위에 아이템이 있을 경우
						//--------------------------------------------------------------------------------
						case Object::OBJECT_CLASS_ITEM :
							{
								Item* pItem = dynamic_cast<Item*>(*itr);

								if (pItem->getItemClass() == Item::ITEM_CLASS_CORPSE) {
									switch (pItem->getItemType()) {
										case SLAYER_CORPSE :
											{
												SlayerCorpse* pSlayerCorpse = dynamic_cast<SlayerCorpse*>(pItem);
												GCAddSlayerCorpse gcAddSlayerCorpse;
												makeGCAddSlayerCorpse(&gcAddSlayerCorpse, pSlayerCorpse);
												pPlayer->sendPacket(&gcAddSlayerCorpse);
											}
											break;
										case VAMPIRE_CORPSE :
											{
												VampireCorpse* pVampireCorpse = dynamic_cast<VampireCorpse*>(pItem);
												GCAddVampireCorpse gcAddVampireCorpse;
												makeGCAddVampireCorpse(&gcAddVampireCorpse, pVampireCorpse);
												pPlayer->sendPacket(&gcAddVampireCorpse);
											}
											break;
										case NPC_CORPSE :
											{
												throw UnsupportedError();
											}
											break;
										case MONSTER_CORPSE :
											{
												MonsterCorpse* pMonsterCorpse = dynamic_cast<MonsterCorpse*>(pItem);
												GCAddMonsterCorpse gcAddMonsterCorpse;
												makeGCAddMonsterCorpse(&gcAddMonsterCorpse, pMonsterCorpse, ix, iy);
												pPlayer->sendPacket(&gcAddMonsterCorpse);
											}
											break;
									}//switch
								} 
								// Mine이 Install되어 있는 경우, DetectMine이 없으면 GCAddNewItemToZone Packet을 보내지 않는다. 
								// 즉 볼 수 없다.
								else if (pItem->getItemClass() == Item::ITEM_CLASS_MINE
									&& pItem->isFlag(Effect::EFFECT_CLASS_INSTALL))
								{
									if (pPC->isFlag(Effect::EFFECT_CLASS_REVEALER) )
									{
										GCAddInstalledMineToZone gcAddMine;
										gcAddMine.setObjectID(pItem->getObjectID());
										gcAddMine.setX(cx);
										gcAddMine.setY(cy);
										gcAddMine.setItemClass(pItem->getItemClass());
										gcAddMine.setItemType(pItem->getItemType());
										gcAddMine.setOptionType(pItem->getOptionType());
										gcAddMine.setDurability(pItem->getDurability());
										pPlayer->sendPacket(&gcAddMine);

									}
								}
								else
								{
									GCAddNewItemToZone gcAddNewItemToZone;
									makeGCAddNewItemToZone(&gcAddNewItemToZone, pItem, ix, iy);
									pPlayer->sendPacket(&gcAddNewItemToZone);
								}
							}
							break;

						////////////////////////////////////////////////////////////
						////////////////////////////////////////////////////////////
						case Object::OBJECT_CLASS_EFFECT :
							{
								Effect* pEffect = dynamic_cast<Effect*>(*itr);
								if (pEffect->getEffectClass() == Effect::EFFECT_CLASS_VAMPIRE_PORTAL)
								{
									EffectVampirePortal* pEffectVampirePortal = dynamic_cast<EffectVampirePortal*>(pEffect);
									ZONE_COORD zonecoord = pEffectVampirePortal->getZoneCoord();

									GCAddVampirePortal gcAddVampirePortal;
									gcAddVampirePortal.setObjectID(pEffect->getObjectID());
									gcAddVampirePortal.setOwnerID(pEffectVampirePortal->getOwnerID());
									gcAddVampirePortal.setX(ix);
									gcAddVampirePortal.setY(iy);
									gcAddVampirePortal.setTargetZoneID(zonecoord.id);
									gcAddVampirePortal.setTargetX(zonecoord.x);
									gcAddVampirePortal.setTargetY(zonecoord.y);
									gcAddVampirePortal.setDuration(pEffectVampirePortal->getRemainDuration());
									gcAddVampirePortal.setCreateFlag(0);

									pPlayer->sendPacket(&gcAddVampirePortal);
								}
								// by sigi. 2002.6.10
								else if (pEffect->getEffectClass() == Effect::EFFECT_CLASS_SANCTUARY)
								{
									EffectSanctuary* pEffectSanctuary = dynamic_cast<EffectSanctuary*>(pEffect);

									ZoneCoord_t centerX = pEffectSanctuary->getCenterX();
									ZoneCoord_t centerY = pEffectSanctuary->getCenterY();
									
									// sanctuary는 중심좌표인 경우만 packet을 보낸다.
									if (centerX==ix && centerY==iy)
									{
										GCAddEffectToTile gcAddEffectToTile;

										gcAddEffectToTile.setObjectID(pEffect->getObjectID());
										gcAddEffectToTile.setXY(ix, iy); 
										gcAddEffectToTile.setEffectID(pEffect->getEffectClass());
										gcAddEffectToTile.setDuration(pEffect->getRemainDuration());

										pPlayer->sendPacket(&gcAddEffectToTile);
									}
								}
								else
								{
									GCAddEffectToTile gcAddEffectToTile;

									gcAddEffectToTile.setObjectID(pEffect->getObjectID());
									gcAddEffectToTile.setXY(ix, iy); 
									gcAddEffectToTile.setEffectID(pEffect->getEffectClass());
									gcAddEffectToTile.setDuration(pEffect->getRemainDuration());
			
									pPlayer->sendPacket(&gcAddEffectToTile);
								}
							}
							break;

						//--------------------------------------------------------------------------------
						// 타일 위에 장애물이 있을 경우
						//--------------------------------------------------------------------------------
						case Object::OBJECT_CLASS_OBSTACLE :
							{
								/*
								*/
							}
							break;

						//--------------------------------------------------------------------------------
						// 타일 위에 포탈이 있을 경우
						//--------------------------------------------------------------------------------
						case Object::OBJECT_CLASS_PORTAL :
							{
								/*
								*/
							}
							break;

						default :
							throw Error("invalid object class");

					}//switch ((*itr)->getObjectClass())
				} // if
				// 보였다가 안보이는 경우.
				else if (oldVS != OUT_OF_SIGHT && newVS == OUT_OF_SIGHT)
				{
					switch((*itr)->getObjectClass())
					{
						case Object::OBJECT_CLASS_CREATURE:
						case Object::OBJECT_CLASS_ITEM:
							{
								GCDeleteObject gcDO;
								gcDO.setObjectID((*itr)->getObjectID());
								pPlayer->sendPacket(&gcDO);
							}
							break;
						case Object::OBJECT_CLASS_EFFECT:
							{
								Effect* pEffect = dynamic_cast<Effect*>(*itr);
								GCDeleteEffectFromTile gcDeleteEffectFromTile;
								gcDeleteEffectFromTile.setObjectID((*itr)->getObjectID());
								gcDeleteEffectFromTile.setEffectID(pEffect->getEffectClass());
								gcDeleteEffectFromTile.setXY(ix, iy);
								pPlayer->sendPacket(&gcDeleteEffectFromTile);
							}
							break;
						default:;
							// Do nothing
					}
				}
			}	// for tile 
		}// for y
	}// for x
	
	__END_CATCH
}



//--------------------------------------------------------------------------------
// broadcast packet
// (x1,y1) (x2,y2) 의 사건을 볼 수 있는,
// owner를 제외한 모든 PC 들에게 패킷을 브로드캐스트한다.
// Tile 전용 스킬 broadcastPacket이다.
// *CAUTION*
// unsigned char 를 ZoneCoord_t 로 사용할 때, overflow 및 underflow 를 주의할 것
//--------------------------------------------------------------------------------
list<Creature*> Zone::broadcastSkillPacket(ZoneCoord_t x1, ZoneCoord_t y1, ZoneCoord_t x2, ZoneCoord_t y2, 
		Packet* pPacket ,list<Creature*> creatureList, bool bConcernDarkness)
	throw(ProtocolException, Error)
{
	__BEGIN_TRY

	ZoneCoord_t ix = 0;
	ZoneCoord_t iy = 0;
	ZoneCoord_t endx = 0;
	ZoneCoord_t endy = 0;
	list<Creature*> cList;

	//-------------------------------------------------------------------
	// 루프 변수 초기화..
	//
	// Plus 변수가 참일 경우 Range 만큼 더 보내 준다..
	// 광역 마법의 결과를 효과적으로 보여주기 위함이다.
	//
	// *NOTE
	//
	// - 최적화를 한다면 VisionInfo에 PLUS_SIGHT라는 변수를 추가하여 연산
	//
	//-------------------------------------------------------------------
	endx = min(m_Width - 1, x1 + maxViewportWidth + 1);
	endy = min(m_Height- 1, y1 + maxViewportLowerHeight + 1);

	for (ix = max(0, x1 - maxViewportWidth - 1); ix <= endx ; ix++) 
	{
		for (iy = max(0, y1 - maxViewportUpperHeight - 1); iy <= endy ; iy++) 
		{
			Tile& rTile = m_pTiles[ix][iy];	// by sigi.2002.5.8

			// 타일에 크리처가 있는 경우에만
			if (rTile.hasCreature()) 
			{
				const slist<Object*> & objectList = rTile.getObjectList();

				for (slist<Object*>::const_iterator itr = objectList.begin() ; itr != objectList.end() && (*itr)->getObjectPriority() <= OBJECT_PRIORITY_BURROWING_CREATURE; itr++) 
				{

					Creature* pCreature = dynamic_cast<Creature*>(*itr);		
					Assert(pCreature != NULL);

					// PC이면서, creature list에 속하지 않으면서 (x,y)를 볼 수 있는 경우
					if (pCreature->isPC())
					{

						// 이 패킷을 발생시킨 놈들인지를 체크한다.
						bool belong = false;
						for (list<Creature*>::const_iterator itr = creatureList.begin() ; itr != creatureList.end() ; itr++) 
						{
							if (pCreature == *itr) 
							{
								belong = true;
								break;
							}
						}

						if (!belong && pCreature->getVisionState(x1,y1) >= IN_SIGHT && pCreature->getVisionState(x2, y2) >= IN_SIGHT)
						{
							// 숨어 있는 넘이 안 보이면서 스킬을 쓸 이유가 없다.. 따라서 HIDE체크는 하지 않는다.
							Player* pPlayer = pCreature->getPlayer();
							pPlayer->sendPacket(pPacket);
							cList.push_back(pCreature);
						}
					}
				}
			}
		}
	}

	// add creature list to cList
	for (list<Creature*>::const_iterator itr = creatureList.begin(); itr != creatureList.end(); itr++)
	{
		cList.push_back(*itr);
	}

	return cList;

	__END_CATCH
}

//////////////////////////////////////////////////////////////////////////////
// (x,y) 의 사건을 볼 수 있는, creatureList 에 소속된 크리처를 제외한 모든 PC 들에게 
// 패킷을 브로드캐스트한다.
//
// *NOTE*
// 지속 Tile Magic일 경우 Plus 를 True로 두게 되며 Plus 변수가 True일 경우..
// Magic 범위의 반지름 만큼 더 범위를 확장하여 보내준다.. 광역 마법이 짤리지 않고,
// 효과적으로 보여주기 위함이다.
//
// *CAUTION*
//
// unsigned char 를 ZoneCoord_t 로 사용할 때, overflow 및 underflow 를 주의할 것
//////////////////////////////////////////////////////////////////////////////
void Zone::broadcastPacket(ZoneCoord_t cx, ZoneCoord_t cy, Packet* pPacket, const list<Creature *> & creatureList, bool Plus, Range_t Range)
	throw(ProtocolException, Error)
{
	__BEGIN_TRY
	
	ZoneCoord_t ix = 0;
	ZoneCoord_t iy = 0;
	ZoneCoord_t endx = 0;
	ZoneCoord_t endy = 0;

	//////////////////////////////////////////////////////////////////////////////
	// 루프 변수 초기화..
	//
	// Plus 변수가 참일 경우 Range 만큼 더 보내 준다..
	// 광역 마법의 결과를 효과적으로 보여주기 위함이다.
	//
	// *NOTE
	// - 최적화를 한다면 VisionInfo에 PLUS_SIGHT라는 변수를 추가하여 연산
	//////////////////////////////////////////////////////////////////////////////
	endx = min(m_Width - 1, cx + maxViewportWidth + 1 + Range);
	endy = min(m_Height - 1, cy + maxViewportLowerHeight  + 1 + Range);

	for (ix =  max(0, cx - maxViewportWidth - 1 - Range); ix <= endx ; ix++) 
	{
		for (iy = max(0, cy - maxViewportUpperHeight - 1 -  Range); iy <= endy ; iy++) 
		{
			Tile& rTile = m_pTiles[ix][iy]; // by sigi. 2002.5.8

			// 타일에 크리처가 있는 경우에만
			if (rTile.hasCreature()) 
			{
				const slist<Object*> & objectList = rTile.getObjectList();
				slist<Object*>::const_iterator itr = objectList.begin();

                for (; itr != objectList.end() && (*itr)->getObjectPriority() <= OBJECT_PRIORITY_BURROWING_CREATURE; itr++) 
				{
					Creature* pCreature = dynamic_cast<Creature*>(*itr);
					Assert(pCreature != NULL);

					// PC이면서, creatureList에 소속되지도 않으면서, (x,y)를 볼 수 있는 경우
					if (pCreature->isPC()) 
					{
						bool belong = false;
						for (list<Creature*>::const_iterator itr = creatureList.begin() ; itr != creatureList.end() ; itr++) 
						{
							if (pCreature == *itr) 
							{
								belong = true;
								break;
							}
						} // for

						if ((!belong && pCreature->getVisionState(cx,cy) >= IN_SIGHT) ||(!belong && Plus)) 
						{
							pCreature->getPlayer()->sendPacket(pPacket);
						} // if
					} // if

				} // for
			}//if
		}//for
	}//for

	__END_CATCH
}

//////////////////////////////////////////////////////////////////////////////
// scan
// (x,y)에서 시야 영역안에 존재하는 모든 객체들의 정보를 받아온다.
//////////////////////////////////////////////////////////////////////////////
void Zone::scan (Creature* pPC, ZoneCoord_t cx, ZoneCoord_t cy, Packet* pPacket)
	throw (ProtocolException, Error)
{
	__BEGIN_TRY

	Assert(pPC->isPC());

	Player* pPlayer = pPC->getPlayer();
	Assert(pPlayer);

	for (ZoneCoord_t ix = max(0, cx - maxViewportWidth - 1), endx = min(m_Width - 1, cx + maxViewportWidth + 1) ; ix <= endx ; ix++) 
	{
		for (ZoneCoord_t iy = max(0, cy - maxViewportUpperHeight - 1), endy = min(m_Height - 1, cy + maxViewportLowerHeight + 1) ; iy <= endy ; iy++) 
		{
			bool bCanSeeThere = (pPC->getVisionState(ix, iy) >= IN_SIGHT);	// 순수 시야만으로 볼 수 있나?
			
			const slist<Object*> & objectList = m_pTiles[ix][iy].getObjectList();

			for (slist<Object*>::const_iterator itr = objectList.begin() ; itr != objectList.end() ; itr++) 
			{
				Assert(*itr != NULL);

				//--------------------------------------------------------------------------------
				//
				// 각 객체의 OBJECT CLASS에 따라서 적합한 GCAddXXX 패킷을 만들어서
				// owner 에게 전송한다. 
				//
				// *NOTES*
				//
				// 가장 출현 확률이 높은 객체 CLASS 가 case 앞부분에 나와야 한다.
				//
				//--------------------------------------------------------------------------------
				switch ((*itr)->getObjectClass()) 
				{
					//--------------------------------------------------------------------------------
					// 타일 위에 크리처가 있을 경우
					//--------------------------------------------------------------------------------
					case Object::OBJECT_CLASS_CREATURE :
						{
							//--------------------------------------------------------------------------------
							// PC의 경우 pPacket을 전송해야 하며, !PC인 경우에는 전송할 필요가 없다.
							// 또한 모든 크리처의 정보를 owner에게 전송해야 한다.
							//--------------------------------------------------------------------------------
							Creature* pCreature = dynamic_cast<Creature*>(*itr);
							Assert(pCreature != NULL);

							if (pCreature == pPC)	// 자기 자신의 정보는 받을 필요가 없다.
								continue;

							switch (pCreature->getCreatureClass()) 
							{
	
								case Creature::CREATURE_CLASS_MONSTER :
									{
										Monster* pMonster = dynamic_cast<Monster*>(pCreature);
										if (bCanSeeThere)
										{
											// by sigi
											Packet* pAddMonsterPacket = createMonsterAddPacket( pMonster, pPC );

											if (pAddMonsterPacket!=NULL)
											{
												pPlayer->sendPacket( pAddMonsterPacket );

												delete pAddMonsterPacket;
											}

											/*
											if (pCreature->isFlag(Effect::EFFECT_CLASS_HIDE)) 
											{
												if (pPC->isVampire() || pPC->isFlag(Effect::EFFECT_CLASS_DETECT_HIDDEN)) 	
												{
													GCAddBurrowingCreature gcABC;
													gcABC.setObjectID(pMonster->getObjectID());
													gcABC.setName(pMonster->getName());
													gcABC.setX(ix);
													gcABC.setY(iy);

													pPlayer->sendPacket(&gcABC);
												}
											} 
											// 박쥐인 상태
											else if (pMonster->isFlag(Effect::EFFECT_CLASS_TRANSFORM_TO_BAT))
											{
												GCAddBat gcAB;
												gcAB.setObjectID(pMonster->getObjectID());
												gcAB.setName(pMonster->getName());
												gcAB.setXYDir(ix, iy, pMonster->getDir());
												gcAB.setItemType( 0 );	// 아직 안 쓴다.
												gcAB.setMaxHP( pMonster->getHP(ATTR_MAX) );
												gcAB.setCurrentHP( pMonster->getHP(ATTR_CURRENT) );

												pPlayer->sendPacket(&gcAB);
											} 
											// 늑대인 상태
											else if (pMonster->isFlag(Effect::EFFECT_CLASS_TRANSFORM_TO_WOLF))
											{
												GCAddWolf gcAW;
												gcAW.setObjectID(pMonster->getObjectID());
												gcAW.setName(pMonster->getName());
												gcAW.setXYDir(ix, iy, pMonster->getDir());
												gcAW.setItemType( 0 );	// 아직 안 쓴다.
												gcAW.setMaxHP( pMonster->getHP(ATTR_MAX) );
												gcAW.setCurrentHP( pMonster->getHP(ATTR_CURRENT) );

												pPlayer->sendPacket(&gcAW);
											}
											else 
											{
												if (!pCreature->isFlag(Effect::EFFECT_CLASS_INVISIBILITY))
												{
													GCAddMonster gcAddMonster;
													makeGCAddMonster(&gcAddMonster, pMonster);
													pPlayer->sendPacket(&gcAddMonster);
												}
												// pCreature는 invisibility상태..
												else if (pPC->isVampire() || pPC->isFlag(Effect::EFFECT_CLASS_DETECT_INVISIBILITY))
												{
													// FIXME
													// 설정에따라서 어떻게 보일지 결정된 후..
													//
													GCAddMonster gcAddMonster;
													makeGCAddMonster(&gcAddMonster, pMonster);
													pPlayer->sendPacket(&gcAddMonster);
												}
											}
											*/
										}

										//--------------------------------------------------------------------------------
										// 몬스터가 PC 를 볼 수 있는 경우, PC 를 몬스터의 Enemy 로 지정한다.
										//--------------------------------------------------------------------------------
										VisionState vs = pMonster->getVisionState(cx,cy);
	
										// Aggressive 몬스터일 경우에만 적으로 등록해준다.
										if (vs >= IN_SIGHT && pMonster->getAlignment() == ALIGNMENT_AGGRESSIVE) 
										{
											if (isPotentialEnemy(pMonster, pPC))
											{
												pMonster->addPotentialEnemy(pPC);
											}
										}
									}
									break;

								case Creature::CREATURE_CLASS_SLAYER :
									{
										// 내가 그곳을 볼 수 있다면(darkness와 관련하여)
										if (bCanSeeThere)
										{	
											// PC 가 Revealer 이펙트를 가지고 있다면 이펙트를 가져온다.
//											EffectRevealer* pEffectRevealer = NULL;
//											if ( pPC->isFlag( Effect::EFFECT_CLASS_REVEALER ) )
//											{
//												pEffectRevealer = dynamic_cast<EffectRevealer*>(pPC->findEffect( Effect::EFFECT_CLASS_REVEALER ) );
//												Assert( pEffectRevealer );
//											}

											if (!pCreature->isFlag(Effect::EFFECT_CLASS_SNIPING_MODE) || pPC->isFlag(Effect::EFFECT_CLASS_DETECT_INVISIBILITY) )
//													|| ( pEffectRevealer != NULL && pEffectRevealer->canSeeSniping( pCreature ) ) )
											{
												Slayer* pSlayer = dynamic_cast<Slayer*>(pCreature);
												GCAddSlayer gcAddSlayer;
												makeGCAddSlayer(&gcAddSlayer, pSlayer);
												pPlayer->sendPacket(&gcAddSlayer);
											}
										}

										// 상대(슬레이어)가 나를 볼 수 있다면	
										// cx, cy에 darkness가 없어야 된다.
										if (pPacket && pCreature->getVisionState(cx, cy) >= IN_SIGHT) 
										{
											// Creature 가 Revealer 이펙트를 가지고 있다면 이펙트를 가져온다.
//											EffectRevealer* pEffectRevealer = NULL;
//											if ( pCreature->isFlag( Effect::EFFECT_CLASS_REVEALER ) )
//											{
//												pEffectRevealer = dynamic_cast<EffectRevealer*>(pCreature->findEffect( Effect::EFFECT_CLASS_REVEALER ) );
//												Assert( pEffectRevealer );
//											}

											Assert(pCreature->getPlayer() != NULL);
											if ((!pPC->isFlag(Effect::EFFECT_CLASS_HIDE) || pCreature->isFlag(Effect::EFFECT_CLASS_DETECT_HIDDEN) ) //|| ( pEffectRevealer != NULL && pEffectRevealer->canSeeHide( pPC ) ) )
												&& (!pPC->isFlag(Effect::EFFECT_CLASS_INVISIBILITY) || pCreature->isFlag(Effect::EFFECT_CLASS_DETECT_INVISIBILITY) ) // || ( pEffectRevealer != NULL && pEffectRevealer->canSeeInvisibility( pPC ) ) ) 
												&& (!pPC->isFlag(Effect::EFFECT_CLASS_SNIPING_MODE) || pCreature->isFlag(Effect::EFFECT_CLASS_DETECT_INVISIBILITY) ) ) // || ( pEffectRevealer != NULL && pEffectRevealer->canSeeSniping( pPC ) ) ) )
											{
												pCreature->getPlayer()->sendPacket(pPacket);
											}
										}
									}
									break;
		
								case Creature::CREATURE_CLASS_VAMPIRE :
									{
										if (bCanSeeThere)
										{
											// PC 가 Revealer 이펙트를 가지고 있다면 이펙트를 가져온다.
//											EffectRevealer* pEffectRevealer = NULL;
//											if ( pPC->isFlag( Effect::EFFECT_CLASS_REVEALER ) )
//											{
//												pEffectRevealer = dynamic_cast<EffectRevealer*>(pPC->findEffect( Effect::EFFECT_CLASS_REVEALER ) );
//												Assert( pEffectRevealer );
//											}

											if (pCreature->isFlag(Effect::EFFECT_CLASS_HIDE)) 
											{
												if (pPC->isVampire() || pPC->isFlag(Effect::EFFECT_CLASS_DETECT_HIDDEN) )
//													|| ( pEffectRevealer != NULL && pEffectRevealer->canSeeHide( pCreature ) ) ) 
												{
													GCAddBurrowingCreature gcABC;
													gcABC.setObjectID(pCreature->getObjectID());
													gcABC.setName(pCreature->getName());
													gcABC.setX(ix);
													gcABC.setY(iy);

													pPlayer->sendPacket(&gcABC);
												}	
											} 
											else 
											{
												if (!pCreature->isFlag(Effect::EFFECT_CLASS_INVISIBILITY))
												{
													Vampire* pVampire = dynamic_cast<Vampire*>(pCreature);
													GCAddVampire gcAddVampire;
													makeGCAddVampire(&gcAddVampire, pVampire);
													pPlayer->sendPacket(&gcAddVampire);
												}
												// pCreature는 invisibility상태..
												else if (pPC->isVampire() || pPC->isFlag(Effect::EFFECT_CLASS_DETECT_INVISIBILITY)) 
//													|| ( pEffectRevealer != NULL && pEffectRevealer->canSeeInvisibility( pCreature ) ) )
												{
													Vampire* pVampire = dynamic_cast<Vampire*>(pCreature);
													GCAddVampire gcAddVampire;
													makeGCAddVampire(&gcAddVampire, pVampire);
													pPlayer->sendPacket(&gcAddVampire);
												}
											}
										}
		
										// 상대가 나를 볼 수 있다면..
										// 상대는 vampire이므로 시야만 가능하다면 darkness와는 관계가 없다. 	
										// 뱀파이어가 상대일땐 스나이핑 모드라면 절대 못 본다...
										//
										// 근데 scan 함수 특성상 snipping 모드를 해제 하지 않고 넘어갈 수는 없다.
										if (pPacket && pCreature->getVisionState(cx, cy) >= IN_SIGHT && !(pPC->isFlag(Effect::EFFECT_CLASS_SNIPING_MODE))) 
										{
											Assert(pCreature->getPlayer() != NULL);
											pCreature->getPlayer()->sendPacket(pPacket);
										}
									}
									break;
		
								case Creature::CREATURE_CLASS_NPC :
									{
										if (bCanSeeThere)
										{
											NPC* pNPC = dynamic_cast<NPC*>(pCreature);
											GCAddNPC gcAddNPC;
											makeGCAddNPC(&gcAddNPC, pNPC);
											pPlayer->sendPacket(&gcAddNPC);
										}
									}
									break;
		
								default :
									throw Error("invalid creature class");
	
							}//switch (pCreature->getCreatureClass())
						}//case Object::OBJECT_CLASS_CREATURE :
	
						break;

					//--------------------------------------------------------------------------------
					// 타일 위에 아이템이 있을 경우
					//--------------------------------------------------------------------------------
					case Object::OBJECT_CLASS_ITEM :
						{
							if (bCanSeeThere)
							{
								Item* pItem = dynamic_cast<Item*>(*itr);

								if (pItem->getItemClass() == Item::ITEM_CLASS_CORPSE) 
								{
									switch (pItem->getItemType()) 
									{
										case SLAYER_CORPSE :
											{
												SlayerCorpse* pSlayerCorpse = dynamic_cast<SlayerCorpse*>(pItem);
												GCAddSlayerCorpse gcAddSlayerCorpse;
												makeGCAddSlayerCorpse(&gcAddSlayerCorpse, pSlayerCorpse);
												pPlayer->sendPacket(&gcAddSlayerCorpse);
											}
											break;
										case VAMPIRE_CORPSE :
											{
												VampireCorpse* pVampireCorpse = dynamic_cast<VampireCorpse*>(pItem);
												GCAddVampireCorpse gcAddVampireCorpse;
												makeGCAddVampireCorpse(&gcAddVampireCorpse, pVampireCorpse);
												pPlayer->sendPacket(&gcAddVampireCorpse);
											}
											break;
										case NPC_CORPSE :
											{
												throw UnsupportedError();
											}
											break;
										case MONSTER_CORPSE :
											{
												MonsterCorpse* pMonsterCorpse = dynamic_cast<MonsterCorpse*>(pItem);
												GCAddMonsterCorpse gcAddMonsterCorpse;
												makeGCAddMonsterCorpse(&gcAddMonsterCorpse, pMonsterCorpse, ix, iy);
												pPlayer->sendPacket(&gcAddMonsterCorpse);
											}
											break;
									}//switch
								}
								else if (pItem->getItemClass() == Item::ITEM_CLASS_MINE && pItem->isFlag(Effect::EFFECT_CLASS_INSTALL))
								{	
									if (pPC->isFlag(Effect::EFFECT_CLASS_REVEALER) )
									{
										GCAddInstalledMineToZone gcAddMine;
										gcAddMine.setObjectID(pItem->getObjectID());
										gcAddMine.setX(cx);
										gcAddMine.setY(cy);
										gcAddMine.setItemClass(pItem->getItemClass());
										gcAddMine.setItemType(pItem->getItemType());
										gcAddMine.setOptionType(pItem->getOptionType());
										gcAddMine.setDurability(pItem->getDurability());
										pPlayer->sendPacket(&gcAddMine);
									}
								}
							   	else 
								{
									GCAddNewItemToZone gcAddNewItemToZone;
									makeGCAddNewItemToZone(&gcAddNewItemToZone, pItem, ix, iy);
									pPlayer->sendPacket(&gcAddNewItemToZone);
								}
							}
						}
						break;

					//--------------------------------------------------------------------------------
					// 타일 위에 이펙트가 있을 경우
					//--------------------------------------------------------------------------------
					case Object::OBJECT_CLASS_EFFECT :
						{
							Effect* pEffect = dynamic_cast<Effect*>(*itr);
							if (bCanSeeThere)
							{
								if (pEffect->getEffectClass() == Effect::EFFECT_CLASS_VAMPIRE_PORTAL)
								{
									EffectVampirePortal* pEffectVampirePortal = dynamic_cast<EffectVampirePortal*>(pEffect);
									ZONE_COORD zonecoord = pEffectVampirePortal->getZoneCoord();

									GCAddVampirePortal gcAddVampirePortal;
									gcAddVampirePortal.setObjectID(pEffect->getObjectID());
									gcAddVampirePortal.setOwnerID(pEffectVampirePortal->getOwnerID());
									gcAddVampirePortal.setX(ix);
									gcAddVampirePortal.setY(iy);
									gcAddVampirePortal.setTargetZoneID(zonecoord.id);
									gcAddVampirePortal.setTargetX(zonecoord.x);
									gcAddVampirePortal.setTargetY(zonecoord.y);
									gcAddVampirePortal.setDuration(pEffectVampirePortal->getRemainDuration());
									gcAddVampirePortal.setCreateFlag(0);

									pPlayer->sendPacket(&gcAddVampirePortal);
								}
								// by sigi. 2002.6.10
								else if (pEffect->getEffectClass() == Effect::EFFECT_CLASS_SANCTUARY)
								{
									EffectSanctuary* pEffectSanctuary = dynamic_cast<EffectSanctuary*>(pEffect);

									ZoneCoord_t centerX = pEffectSanctuary->getCenterX();
									ZoneCoord_t centerY = pEffectSanctuary->getCenterY();
									
									// sanctuary는 중심좌표인 경우만 packet을 보낸다.
									if (centerX==ix && centerY==iy)
									{
										GCAddEffectToTile gcAddEffectToTile;

										gcAddEffectToTile.setObjectID(pEffect->getObjectID());
										gcAddEffectToTile.setXY(ix, iy); 
										gcAddEffectToTile.setEffectID(pEffect->getEffectClass());
										gcAddEffectToTile.setDuration(pEffect->getRemainDuration());

										pPlayer->sendPacket(&gcAddEffectToTile);
									}
								}
								else
								{
									GCAddEffectToTile gcAddEffectToTile;

									gcAddEffectToTile.setObjectID(pEffect->getObjectID());
									gcAddEffectToTile.setXY(ix, iy); 
									gcAddEffectToTile.setEffectID(pEffect->getEffectClass());
									gcAddEffectToTile.setDuration(pEffect->getRemainDuration());

									pPlayer->sendPacket(&gcAddEffectToTile);
								}
							}
						}
						break;


					//--------------------------------------------------------------------------------
					// 타일 위에 장애물이 있을 경우
					//--------------------------------------------------------------------------------
					case Object::OBJECT_CLASS_OBSTACLE :
						{
							/*
							*/
						}
						break;

					//--------------------------------------------------------------------------------
					// 타일 위에 포탈이 있을 경우
					//--------------------------------------------------------------------------------
					case Object::OBJECT_CLASS_PORTAL :
						{
							/*
							*/
						}
						break;

					default :
						throw Error("invalid object class");

				}//switch ((*itr)->getObjectClass())
			}//for
			
		}//for
	}//for

	__END_CATCH
}

//////////////////////////////////////////////////////////////////////////////
// 몬스터가 존의 (x,y)에 새로 리젠되었을 경우, 시야 영역안에 존재하는 모든 PC들에게
// GCAddXXX 패킷을 보내면서, 동시에 그 PC 를 잠재적인 적으로 간주한다.
//////////////////////////////////////////////////////////////////////////////
void Zone::scanPC (Creature* pCreature)
	throw (ProtocolException, Error)
{
	__BEGIN_TRY

	Monster* pMonster = NULL;

	Assert(pCreature != NULL);

	ZoneCoord_t cx = pCreature->getX();
	ZoneCoord_t cy = pCreature->getY();

	Packet*                pGCAddXXX = NULL;

	// 크리쳐의 종류에 따라, 패킷을 만들어둔다.
	Creature::CreatureClass CClass = pCreature->getCreatureClass();

	bool isMonster = pCreature->isMonster();
	bool isMonsterHide = false;
	bool isMonsterInvisibility = false;

	if (CClass == Creature::CREATURE_CLASS_MONSTER)
	{
		pMonster = dynamic_cast<Monster*>(pCreature);

		// by sigi
		pGCAddXXX = createMonsterAddPacket( pMonster, NULL );

		isMonsterHide = pMonster->isFlag(Effect::EFFECT_CLASS_HIDE);
		isMonsterInvisibility = pMonster->isFlag(Effect::EFFECT_CLASS_INVISIBILITY);

		/*
		if (pCreature->isFlag(Effect::EFFECT_CLASS_HIDE))
		{
			gcABC.setObjectID(pMonster->getObjectID());
			gcABC.setName(pMonster->getName());
			gcABC.setX(cx);
			gcABC.setY(cy);
			pGCAddXXX = &gcABC;
		}
		else
		{
			makeGCAddMonster(&gcAddMonster, pMonster);
			pGCAddXXX = &gcAddMonster;
		}
		*/
	}
	else if (CClass == Creature::CREATURE_CLASS_NPC)
	{
		NPC* pNPC = dynamic_cast<NPC*>(pCreature);

		GCAddNPC* pGCAddNPC = new GCAddNPC;

		makeGCAddNPC(pGCAddNPC, pNPC);

		pGCAddXXX = pGCAddNPC;
	}
	else 
	{
		Assert(false);
	}

	for (ZoneCoord_t ix = max(0, cx - maxViewportWidth - 1), endx = min(m_Width - 1, cx + maxViewportWidth + 1) ; ix <= endx ; ix++) 
	{
		for (ZoneCoord_t iy = max(0, cy - maxViewportUpperHeight - 1), endy = min(m_Height - 1, cy + maxViewportLowerHeight + 1) ; iy <= endy ; iy++) 
		{
			const slist<Object*> & objectList = m_pTiles[ix][iy].getObjectList();
			slist<Object*>::const_iterator itr = objectList.begin();

			for (; itr != objectList.end() && (*itr)->getObjectPriority() <= OBJECT_PRIORITY_BURROWING_CREATURE ; itr++) 
			{
				if ((*itr)->getObjectClass() == Object::OBJECT_CLASS_CREATURE)
				{
					Creature* pPC = dynamic_cast<Creature*>(*itr);
					Assert(pPC != NULL);

					// PC 이면서, 크리처를 볼 수 있는 경우
					if (pPC->isPC() && pPC->getVisionState(cx,cy) >= IN_SIGHT)
					{
						// Creature 가 Revealer 이펙트를 가지고 있다면 이펙트를 가져온다.
//						EffectRevealer* pEffectRevealer = NULL;
//						if ( pCreature->isFlag( Effect::EFFECT_CLASS_REVEALER ) )
//						{
//							pEffectRevealer = dynamic_cast<EffectRevealer*>(pCreature->findEffect( Effect::EFFECT_CLASS_REVEALER ) );
//							Assert( pEffectRevealer );
//						}

						// 몬스터가 스나이핑을 쓸리는 없다 그래서 DETECT_HIDDEN과 INVISIBILITY만 체크 한다.
						if (pPC->isVampire() ||
							((!isMonsterHide || pPC->isFlag(Effect::EFFECT_CLASS_DETECT_HIDDEN))// || ( pEffectRevealer != NULL && pEffectRevealer->canSeeHide( pMonster ) ) )
							&& (!isMonsterInvisibility || pPC->isFlag(Effect::EFFECT_CLASS_DETECT_INVISIBILITY) ))// || ( pEffectRevealer != NULL && pEffectRevealer->canSeeInvisibility( pMonster ) ) ))
							)
						{
							pPC->getPlayer()->sendPacket(pGCAddXXX);
						}

						if (isMonster)
						{
							// (cx,cy)에 있는 몬스터가 (ix,iy)에 있는 PC를 볼 수 있는가?
							VisionState vs = pMonster->getVisionState(ix,iy);
							if (vs >= IN_SIGHT && pMonster->getAlignment() == ALIGNMENT_AGGRESSIVE) 
							{
								if (isPotentialEnemy(pMonster, pPC))
								{
									pMonster->addPotentialEnemy(pPC);
								}
							}
						}
					}

				} // if (creature)

			} // for itr

		} // for y
	} // for x

	if (pGCAddXXX != NULL)
	{
		delete pGCAddXXX;
	}

	__END_CATCH
}


//////////////////////////////////////////////////////////////////////////////
// pPC가 pTarget을 볼 수 있는가?
//////////////////////////////////////////////////////////////////////////////
bool Zone::canSee(Creature* pPC, Creature* pTarget) throw(Error)
{
	ZoneCoord_t targetX = pTarget->getX(), targetY = pTarget->getY();

	// Revealer 이펙트를 가져온다.
//	EffectRevealer* pEffectRevealer = NULL;
//	if ( pPC->isFlag(Effect::EFFECT_CLASS_REVEALER) )
//	{
//		pEffectRevealer = dynamic_cast<EffectRevealer*>(pPC->findEffect(Effect::EFFECT_CLASS_REVEALER));
//		Assert( pEffectRevealer != NULL );
//	}

	if (pPC->getVisionState(targetX, targetY) >= IN_SIGHT)
	{
		if (pPC->isVampire() && pTarget->isVampire()) return true;

		if ( ( !pTarget->isFlag(Effect::EFFECT_CLASS_HIDE) || pPC->isFlag(Effect::EFFECT_CLASS_DETECT_HIDDEN) )// || ( pEffectRevealer != NULL && pEffectRevealer->canSeeHide( pTarget ) ) )
				&& (!pTarget->isFlag(Effect::EFFECT_CLASS_INVISIBILITY) || pPC->isFlag(Effect::EFFECT_CLASS_DETECT_INVISIBILITY) )// || ( pEffectRevealer != NULL && pEffectRevealer->canSeeInvisibility( pTarget ) ) )
				&& (!pTarget->isFlag(Effect::EFFECT_CLASS_SNIPING_MODE) || pPC->isFlag(Effect::EFFECT_CLASS_DETECT_INVISIBILITY) ))// || ( pEffectRevealer != NULL && pEffectRevealer->canSeeSniping( pTarget ) ) ) )  
		{
			return true;
		}
	}

	return false;
}

//////////////////////////////////////////////////////////////////////////////
// P(x1,y1)에서 Q(x2,y2)로 빠른 이동한 크리처가 주변 영역에 존재하는 PC들에게 
// 브로드캐스트하는 메쏘드이다.
// for Skill FlashSliding, ShadowWalk
//////////////////////////////////////////////////////////////////////////////
bool Zone::moveFastPC(Creature* pPC, ZoneCoord_t x1, ZoneCoord_t y1, ZoneCoord_t x2, ZoneCoord_t y2, bool bSendMove)
	throw (ProtocolException, Error)
{
	__BEGIN_TRY 
	__BEGIN_DEBUG

	// 이 메쏘드는 PC 를 대상으로 한다.
	Assert(pPC->isPC());
	
	if (pPC->isFlag(Effect::EFFECT_CLASS_PARALYZE) || pPC->isFlag(Effect::EFFECT_CLASS_HIDE) || pPC->isFlag(Effect::EFFECT_CLASS_CAUSE_CRITICAL_WOUNDS) )
	{
		// do nothing
		return false;
	} 

	// 적당한 종착지점을 찾는다.
	// 전면부에서 적당한 지점..4개 검색
	Dir_t dir = calcDirection(x1, y1, x2, y2);

	// g_FastMoveSearchX, Y로 찾으면 된다. by sigi. 2002.5.8
	int* searchX = g_FastMoveSearchX[dir];
	int* searchY = g_FastMoveSearchY[dir];

	/*
	int searchX[] = {0, 0, 0, 0};
	int searchY[] = {0, 0, 0, 0};
    switch(dir)
	{
		case LEFT:
			searchX[0] = 0;			//					  |	2순위
			searchX[1] = 1;			//		목적지(0순위) | 1순위			원위치
			searchX[2] = 1;			//					  |	3순위
			searchX[3] = 1;			//
			
			searchY[0] = 0;
			searchY[1] = 0;
			searchY[2] = -1;
			searchY[3] = 1;
			break;
		case RIGHT:
			searchX[0] = 0;
			searchX[1] = -1;
			searchX[2] = -1;
			searchX[3] = -1;
			
			searchY[0] = 0;
			searchY[1] = 0;
			searchY[2] = -1;
			searchY[3] = 1;
			break;
		case UP:
			searchX[0] = 0;
			searchX[1] = 0;
			searchX[2] = -1;
			searchX[3] = 1;
			
			searchY[0] = 0;
			searchY[1] = 1;
			searchY[2] = 1;
			searchY[3] = 1;
			break;
		case DOWN:
			searchX[0] = 0;
			searchX[1] = 0;
			searchX[2] = -1;
			searchX[3] = 1;
			
			searchY[0] = 0;
			searchY[1] = -1;
			searchY[2] = -1;
			searchY[3] = -1;
			break;
		case LEFTUP:
			searchX[0] = 0;
			searchX[1] = 1;
			searchX[2] = 0;
			searchX[3] = 1;
			
			searchY[0] = 0;
			searchY[1] = 1;
			searchY[2] = 1;
			searchY[3] = 0;
			break;
		case RIGHTUP:
			searchX[0] = 0;
			searchX[1] = -1;
			searchX[2] = 0;
			searchX[3] = -1;
			
			searchY[0] = 0;
			searchY[1] = 1;
			searchY[2] = 1;
			searchY[3] = 0;
			break;
		case LEFTDOWN:
			searchX[0] = 0;
			searchX[1] = 1;
			searchX[2] = 0;
			searchX[3] = 1;
			
			searchY[0] = 0;
			searchY[1] = -1;
			searchY[2] = -1;
			searchY[3] = 0;
			break;
		case RIGHTDOWN:
			searchX[0] = 0;
			searchX[1] = -1;
			searchX[2] = 0;
			searchX[3] = -1;
			
			searchY[0] = 0;
			searchY[1] = -1;
			searchY[2] = -1;
			searchY[3] = 0;
			break;
	}	
	*/

	// 빈 타일인지 확인.
	int i=0;
	for(i = 0; i< 4; i++)
	{
		int targetX = x2 + searchX[i], targetY = y2 + searchY[i];
		if (targetX >= 0 && targetX < m_Width && targetY >= 0 && targetY < m_Height && !m_pTiles[targetX][targetY].isBlocked(pPC->getMoveMode()) && !m_pTiles[targetX][targetY].hasPortal())
		{
			x2 = targetX;
			y2 = targetY;
			break;
		}
	}
	if (i == 4) 
	{
		return false;	// 빈타일을 못찾았다!
	}
	
	Player* pPlayer = pPC->getPlayer();
	Assert(pPlayer);

	GCFastMove gcFastMove;
	gcFastMove.setObjectID(pPC->getObjectID());
	gcFastMove.setXY(x1, y1, x2, y2);

	pPlayer->sendPacket(&gcFastMove);
	
	//////////////////////////////////////////////////////////////
	// move의 종류....
	// 이에따라 GCDelete나 Add등을 보내줘야 할 수 도 있다.
	
	// PC의 좌표 변경.
	pPC->setXYDir(x2, y2, dir);
	// 이전 타일에서 크리처를 삭제한다.

	try {
		m_pTiles[x1][y1].deleteCreature(pPC->getObjectID());	
	} catch (Error& e) {
		filelog("assertTile.txt", "moveFastPC : %s", e.toString().c_str());
		throw;
	}

	// 새 타일에 크리처를 추가한다.
	m_pTiles[x2][y2].addCreature(pPC);

	try {
		checkMine(this, pPC, x2, y2);
	} catch ( Throwable & t ) {
		filelog("CheckMineBug.txt", "%s : %s", "moveFastPC", t.toString().c_str());
	}


	//--------------------------------------------------------------------------------
	// GCAddSlayer/GCAddVampire 패킷을 만들어둔다.
	// 현재의 정책에 의하면, GCAdd 패킷은 현재의 좌표를 바탕으로 한다.
	//--------------------------------------------------------------------------------
	Packet* pGCAddXXX = NULL;

	if (pPC->getCreatureClass() == Creature::CREATURE_CLASS_SLAYER) 
	{
		Slayer* pSlayer = dynamic_cast<Slayer*>(pPC);
		GCAddSlayer* pGCAddSlayer = new GCAddSlayer(pSlayer->getSlayerInfo3());
		pGCAddSlayer->setEffectInfo(pSlayer->getEffectInfo());

		pGCAddXXX = pGCAddSlayer;
	} 
	else if (pPC->getCreatureClass() == Creature::CREATURE_CLASS_VAMPIRE) 
	{
		Vampire* pVampire = dynamic_cast<Vampire*>(pPC);

		// 음.. hide상태에서 움직일 수는 없지만..
		// 미래를 대비.
		if (pPC->isFlag(Effect::EFFECT_CLASS_HIDE))
		{
			GCAddBurrowingCreature* pGCABC = new GCAddBurrowingCreature();
			pGCABC->setObjectID(pVampire->getObjectID());
			pGCABC->setName(pVampire->getName());
			pGCABC->setX(x2);
			pGCABC->setY(y2);
			pGCAddXXX = pGCABC;	
		}
		else
		{
			GCAddVampire* pGCAddVampire = new GCAddVampire(pVampire->getVampireInfo3());
			pGCAddVampire->setEffectInfo(pVampire->getEffectInfo());

			pGCAddXXX = pGCAddVampire;
		}
	}

	//--------------------------------------------------------------------------------
	// GCDeleteObject 패킷을 만들어둔다.
	//--------------------------------------------------------------------------------
	GCDeleteObject gcDeleteObject;
	gcDeleteObject.setObjectID(pPC->getObjectID());


	// 총 시야의 범위를 구한다.
	ZoneCoord_t minX, maxX, minY, maxY;
	if (x1 < x2)
	{
		minX = max(0, x1 - maxViewportWidth);
		maxX = min(m_Width-1, x2 + maxViewportWidth);
	}
	else
	{
		minX = max(0, x2 - maxViewportWidth);
		maxX = min(m_Width-1, x1 + maxViewportWidth);
	}
	if (y1 < y2)
	{
		minY = max(0, y1 - maxViewportUpperHeight);
		maxY = min(m_Height-1, y2 + maxViewportLowerHeight);
	}
	else
	{
		minY = max(0, y2 - maxViewportUpperHeight);
		maxY = min(m_Height-1, y1 + maxViewportLowerHeight);
	}

	Sight_t sight = pPC->getSight();

	VisionInfo* pVisionInfo = g_pVisionInfoManager->getVisionInfo(sight, pPC->getDir());

	// Revealer 이펙트를 가져온다.
//	EffectRevealer* pEffectRevealer = NULL;
//	if ( pPC->isFlag( Effect::EFFECT_CLASS_REVEALER ) )
//	{
//		pEffectRevealer = dynamic_cast<EffectRevealer*>( pPC->findEffect( Effect::EFFECT_CLASS_REVEALER ) );
//		Assert( pEffectRevealer );
//	}

	for (ZoneCoord_t ix = minX ; ix <= maxX ; ix++) 
	{
		for (ZoneCoord_t iy = minY ; iy <= maxY ; iy++) 
		{
			const slist<Object*> & objectList = m_pTiles[ix][iy].getObjectList();

			slist<Object*>::const_iterator itr = objectList.begin();

			// visionInfo 때문에..
			// if - do~while()로 구조 변경 by sigi. 2002.5.8
			if (itr != objectList.end())
			{

				// 이전 좌표 P(x1,y1)에서 I(ix,iy)가 어떻게 보이는가?
				VisionState prevVisionState = pVisionInfo->getVisionState(x1,y1,ix,iy);
				// 현재 좌표 Q(x2,y2)에서 I(ix,iy)가 어떻게 보이는가?
				VisionState curVisionState = pVisionInfo->getVisionState(x2,y2,ix,iy);

				do
				{
					Assert(*itr != NULL);

					//--------------------------------------------------------------------------------
					//
					// 각 객체의 OBJECT CLASS에 따라서 적합한 GCAddXXX 패킷을 만들어서
					// owner 에게 전송한다. 
					//
					// *NOTES*
					//
					// 가장 출현 확률이 높은 객체 CLASS 가 case 앞부분에 나와야 한다.
					//
					//--------------------------------------------------------------------------------
					switch ((*itr)->getObjectClass()) 
					{
						//--------------------------------------------------------------------------------
						// 타일 위에 크리처가 있을 경우
						//--------------------------------------------------------------------------------
						case Object::OBJECT_CLASS_CREATURE :
							{
								Creature* pCreature = dynamic_cast<Creature*>(*itr);
								Assert(pCreature != NULL);

								// 자기 자신의 정보는 받을 필요가 없다.
								if (pCreature == pPC) continue;

								switch (pCreature->getCreatureClass()) 
								{
	
									case Creature::CREATURE_CLASS_MONSTER :
										{
											Monster* pMonster = dynamic_cast<Monster*>(pCreature);

											//--------------------------------------------------------------------------------
											//
											// 이전 좌표에서는 이 몬스터를 볼 수 없었으나, 도착 좌표에서 이 몬스터를 보게 될
											// 경우 GCAddMonster 패킷을 전송한다.
											//
											//--------------------------------------------------------------------------------
											if (prevVisionState == OUT_OF_SIGHT && curVisionState >= IN_SIGHT) 
											{
												Packet* pAddMonsterPacket = createMonsterAddPacket( pMonster, pPC );

												if (pAddMonsterPacket!=NULL)
												{
													pPlayer->sendPacket( pAddMonsterPacket );
													delete pAddMonsterPacket;
												}
												/*
												if (pMonster->isFlag(Effect::EFFECT_CLASS_HIDE))
												{
													if (pPC->isVampire() || pPC->isFlag(Effect::EFFECT_CLASS_DETECT_HIDDEN)) 
													{
														GCAddMonster gcAddMonster;
														makeGCAddMonster(&gcAddMonster, pMonster);
														pPlayer->sendPacket(&gcAddMonster);
													}
												} 
												else 
												{ 
													if (!pMonster->isFlag(Effect::EFFECT_CLASS_INVISIBILITY))
													{
														GCAddMonster gcAddMonster;
														makeGCAddMonster(&gcAddMonster, pMonster);
														pPlayer->sendPacket(&gcAddMonster);
													}
													// pCreature는 invisibility상태..
													else if (pPC->isVampire() || pPC->isFlag(Effect::EFFECT_CLASS_DETECT_INVISIBILITY))
													{
														// FIXME
														// 설정에따라서 어떻게 보일지 결정된 후..
														//
														GCAddMonster gcAddMonster;
														makeGCAddMonster(&gcAddMonster, pMonster);
														pPlayer->sendPacket(&gcAddMonster);
													}
												}
												*/
											}

											//--------------------------------------------------------------------------------
											// PC를 몬스터의 잠재적인 적으로 지정해준다.
											//--------------------------------------------------------------------------------
											VisionState vs = pMonster->getVisionState(x2,y2);

											// Aggressive 몬스터에게만 적으로 등록시켜준다.
											if (vs >= IN_SIGHT && pMonster->getAlignment() == ALIGNMENT_AGGRESSIVE) 
											{
												if (isPotentialEnemy(pMonster, pPC))
												{
													pMonster->addPotentialEnemy(pPC);
												}
											}

										}
										break;

									//--------------------------------------------------------------------------------
									//
									//--------------------------------------------------------------------------------
									case Creature::CREATURE_CLASS_SLAYER :
										{
											//--------------------------------------------------------------------------------
											// 이전 좌표에서는 보이지 않다가, 이번 좌표에서 새로 보이게 된 크리처만
											// GCAddXXX 를 받아온다. 계속 보일 경우에는 받아오지 않는다.
											//--------------------------------------------------------------------------------
											if (curVisionState >= IN_SIGHT && prevVisionState == OUT_OF_SIGHT) 
											{
												// 보는 이가 스나이핑 상태라면 디텍트 되어 있어야 한다.
												if (!pCreature->isFlag(Effect::EFFECT_CLASS_SNIPING_MODE)
													|| pPC->isFlag(Effect::EFFECT_CLASS_DETECT_INVISIBILITY) )
//													|| ( pEffectRevealer != NULL && pEffectRevealer->canSeeSniping( pCreature ) ) ) 
												{
													Slayer* pSlayer = dynamic_cast<Slayer*>(pCreature);
													GCAddSlayer gcAddSlayer(pSlayer->getSlayerInfo3()); 
													gcAddSlayer.setEffectInfo(pSlayer->getEffectInfo());
													pPlayer->sendPacket(&gcAddSlayer);
												}
												
											}

											Assert(pCreature->getPlayer() != NULL);

											//--------------------------------------------------------------------------------
											//
											// Q(x2,y2)가 이 크리처의 시야 사각형의 경계에 위치하면서, P(x1,y1)은 사각형의 외부, 
											// 즉 보이지 않는 경우에만 GCAddXXX 패킷을 전송한다. 이렇게 하지 않으면, PC
											// 크리처가 pCreature의 시야 경계에서 계속 움직이게 되면 계속 서버는 GCAddXXX 패킷을
											// 보내야만 한다.
											//
											// 요약하면,
											//
											// OUT_OF_SIGHT -> ON_SIGHT/NEW_SIGHT : GCAddXXX 
											// IN_SIGHT/ON_SIGHT/NEW_SIGHT -> IN_SIGHT/ON_SIGHT/NEW_SIGHT : GCMove
											//
											//--------------------------------------------------------------------------------
											VisionState prevVS = pCreature->getVisionState(x1,y1);
											VisionState currVS = pCreature->getVisionState(x2,y2);

											// 보이지 않는 영역에서, 경계 영역을 거치지 않고 바로
											// 시야 내부 영역으로 들어온다는 것은 불가능하다.

											// Revealer 이펙트를 가져온다.
//											EffectRevealer* pEffectRevealerCreature = NULL;
//											if ( pCreature->isFlag( Effect::EFFECT_CLASS_REVEALER ) )
//											{
//												pEffectRevealerCreature = dynamic_cast<EffectRevealer*>( pCreature->findEffect( Effect::EFFECT_CLASS_REVEALER ) );
//												Assert( pEffectRevealerCreature );
//											}

											// 상대에게 PC의 등장을 알리는 패킷.
											if ((!pPC->isFlag(Effect::EFFECT_CLASS_HIDE) || pCreature->isFlag(Effect::EFFECT_CLASS_DETECT_HIDDEN) ) //|| ( pEffectRevealerCreature != NULL && pEffectRevealerCreature->canSeeHide( pPC ) ) ) 
												&& (!pPC->isFlag(Effect::EFFECT_CLASS_INVISIBILITY) || pCreature->isFlag(Effect::EFFECT_CLASS_DETECT_INVISIBILITY) ) //|| ( pEffectRevealerCreature != NULL && pEffectRevealerCreature->canSeeInvisibility( pPC ) ) ) 
												&& (!pPC->isFlag(Effect::EFFECT_CLASS_SNIPING_MODE) || pCreature->isFlag(Effect::EFFECT_CLASS_DETECT_INVISIBILITY) )) //|| ( pEffectRevealerCreature != NULL && pEffectRevealerCreature->canSeeSniping( pPC) ) ) )
											{
												if (prevVS == OUT_OF_SIGHT && currVS >= IN_SIGHT) 
												{
													pCreature->getPlayer()->sendPacket(pGCAddXXX);
													pCreature->getPlayer()->sendPacket(&gcFastMove);
												} 
												else if (prevVS >= IN_SIGHT && currVS >= IN_SIGHT) 
												{
													pCreature->getPlayer()->sendPacket(&gcFastMove);
												}
												else if (prevVS >= IN_SIGHT && currVS == OUT_OF_SIGHT)
												{
													pCreature->getPlayer()->sendPacket(&gcDeleteObject);
												}
											}
										}
										break;

									case Creature::CREATURE_CLASS_VAMPIRE :
										{
											//--------------------------------------------------------------------------------
											// 이전 좌표에서는 보이지 않다가, 이번 좌표에서 새로 보이게 된 크리처만
											// GCAddXXX 를 받아온다. 이전에도 NEW_SIGHT 이고, 지금도 NEW_SIGHT 이면,
											// 새로 받아오지 않는다.
											//--------------------------------------------------------------------------------
											if (curVisionState >= IN_SIGHT && prevVisionState == OUT_OF_SIGHT) 
											{
												if (pCreature->isFlag(Effect::EFFECT_CLASS_HIDE)) 
												{
													if (pPC->isVampire() || pPC->isFlag(Effect::EFFECT_CLASS_DETECT_HIDDEN) )
//														|| ( pEffectRevealer != NULL && pEffectRevealer->canSeeHide( pCreature ) ) ) 
													{
														GCAddBurrowingCreature gcABC;
														gcABC.setObjectID(pCreature->getObjectID());
														gcABC.setName(pCreature->getName());
														gcABC.setX(ix);
														gcABC.setY(iy);
														pPlayer->sendPacket(&gcABC);
													}
												} 
												else 
												{
													if (!pCreature->isFlag(Effect::EFFECT_CLASS_INVISIBILITY))
													{
														Vampire* pVampire = dynamic_cast<Vampire*>(pCreature);
														GCAddVampire gcAddVampire(pVampire->getVampireInfo3());
														gcAddVampire.setEffectInfo(pVampire->getEffectInfo());
														pPlayer->sendPacket(&gcAddVampire);
													}
													// pCreature는 invisibility상태..
													else if (pPC->isVampire() || pPC->isFlag(Effect::EFFECT_CLASS_DETECT_INVISIBILITY) )
//															|| ( pEffectRevealer != NULL && pEffectRevealer->canSeeInvisibility( pCreature ) ) )
													{
														Vampire* pVampire = dynamic_cast<Vampire*>(pCreature);
														GCAddVampire gcAddVampire(pVampire->getVampireInfo3());
														gcAddVampire.setEffectInfo(pVampire->getEffectInfo());
														pPlayer->sendPacket(&gcAddVampire);
													}
												}
											}

											Assert(pCreature->getPlayer() != NULL);

											//--------------------------------------------------------------------------------
											// Q(x2,y2)가 이 크리처의 시야 사각형의 경계에 위치하면서, P(x1,y1)은 사각형의 외부, 
											// 즉 보이지 않는 경우에만 GCAddXXX 패킷을 전송한다. 이렇게 하지 않으면, PC
											// 크리처가 pCreature의 시야 경계에서 계속 움직이게 되면 계속 서버는 GCAddXXX 패킷을
											// 보내야만 한다.
											//
											// 요약하면,
											//
											// OUT_OF_SIGHT -> ON_SIGHT/NEW_SIGHT : GCAddXXX 
											// IN_SIGHT/ON_SIGHT/NEW_SIGHT -> IN_SIGHT/ON_SIGHT/NEW_SIGHT : GCMove
											//
											//--------------------------------------------------------------------------------
											VisionState prevVS = pCreature->getVisionState(x1,y1);
											VisionState currVS = pCreature->getVisionState(x2,y2);

											// 상대는 뱀파이어이므로 나의 darkness상태는 관계없다.
											// Hide도 관계없다.
											// *NOTE
											// 상대가 슬레이어라면 슬레이어가 스나이핑 상태인지를 체크 해야 한다.
											if (!pPC->isSlayer() || !pPC->isFlag(Effect::EFFECT_CLASS_SNIPING_MODE)) 
											{
												if (prevVS == OUT_OF_SIGHT && currVS >= IN_SIGHT) 
												{
													pCreature->getPlayer()->sendPacket(pGCAddXXX);
													pCreature->getPlayer()->sendPacket(&gcFastMove);
												}
												else if (prevVS >= IN_SIGHT && currVS >= IN_SIGHT) 
												{
													pCreature->getPlayer()->sendPacket(&gcFastMove);
												}
												else if (prevVS >= IN_SIGHT && currVS == OUT_OF_SIGHT)
												{
													pCreature->getPlayer()->sendPacket(&gcDeleteObject);
												}
											}
										}
										break;
							
									case Creature::CREATURE_CLASS_NPC :
										{
											NPC* pNPC = dynamic_cast<NPC*>(pCreature);

											//--------------------------------------------------------------------------------
											//
											// 이전 좌표에서는 이 몬스터를 볼 수 없었으나, 도착 좌표에서 이 몬스터를 보게 될
											// 경우 GCAddMonster 패킷을 전송한다.
											//
											//--------------------------------------------------------------------------------
											if (prevVisionState == OUT_OF_SIGHT && curVisionState >= IN_SIGHT) 
											{
												GCAddNPC gcAddNPC;
												makeGCAddNPC(&gcAddNPC, pNPC);
												pPlayer->sendPacket(&gcAddNPC);
											}
										}
										break;

									default :
										throw Error("invalid creature class");
		
								}//switch (pCreature->getCreatureClass())
			
							}//case Object::OBJECT_CLASS_CREATURE :
		
							break;

						//--------------------------------------------------------------------------------
						// 타일 위에 아이템이 있을 경우
						//--------------------------------------------------------------------------------
						case Object::OBJECT_CLASS_ITEM :
							{
								if (curVisionState >= IN_SIGHT && prevVisionState == OUT_OF_SIGHT)
								{
									Item* pItem = dynamic_cast<Item*>(*itr);

									if (pItem->getItemClass() == Item::ITEM_CLASS_CORPSE) 
									{
										switch (pItem->getItemType()) 
										{
											case SLAYER_CORPSE :
												{
													SlayerCorpse* pSlayerCorpse = dynamic_cast<SlayerCorpse*>(pItem);
													GCAddSlayerCorpse gcAddSlayerCorpse;
													makeGCAddSlayerCorpse(&gcAddSlayerCorpse, pSlayerCorpse);
													pPlayer->sendPacket(&gcAddSlayerCorpse);
												}
												break;
											case VAMPIRE_CORPSE :
												{
													VampireCorpse* pVampireCorpse = dynamic_cast<VampireCorpse*>(pItem);
													GCAddVampireCorpse gcAddVampireCorpse;
													makeGCAddVampireCorpse(&gcAddVampireCorpse, pVampireCorpse);
													pPlayer->sendPacket(&gcAddVampireCorpse);
												}
												break;
											case NPC_CORPSE :
												{
													throw UnsupportedError();
												}
												break;
											case MONSTER_CORPSE :
												{
													MonsterCorpse* pMonsterCorpse = dynamic_cast<MonsterCorpse*>(pItem);
													GCAddMonsterCorpse gcAddMonsterCorpse;
													makeGCAddMonsterCorpse(&gcAddMonsterCorpse, pMonsterCorpse, ix, iy);
													pPlayer->sendPacket(&gcAddMonsterCorpse);
												}
												break;
										}//switch
									}
									else if (pItem->getItemClass() == Item::ITEM_CLASS_MINE
											&& pItem->isFlag(Effect::EFFECT_CLASS_INSTALL))
									{	
										if (	pPC->isFlag(Effect::EFFECT_CLASS_REVEALER) )
										{
											GCAddInstalledMineToZone gcAddMine;
											gcAddMine.setObjectID(pItem->getObjectID());
											gcAddMine.setX(ix);
											gcAddMine.setY(iy);
											gcAddMine.setItemClass(pItem->getItemClass());
											gcAddMine.setItemType(pItem->getItemType());
											gcAddMine.setOptionType(pItem->getOptionType());
											gcAddMine.setDurability(pItem->getDurability());
											pPlayer->sendPacket(&gcAddMine);
										}
									} 
									else 
									{
										GCAddNewItemToZone gcAddNewItemToZone;
										makeGCAddNewItemToZone(&gcAddNewItemToZone, pItem, ix, iy);
										pPlayer->sendPacket(&gcAddNewItemToZone);
									}
								}
							}
							break;

						//--------------------------------------------------------------------------------
						// 타일 위에 이펙트가 있을 경우
						//--------------------------------------------------------------------------------
						case Object::OBJECT_CLASS_EFFECT :
							{
								Effect* pEffect = dynamic_cast<Effect*>(*itr);
								
								if (curVisionState >= IN_SIGHT && prevVisionState == OUT_OF_SIGHT) 
								{
									if (pEffect->getEffectClass() == Effect::EFFECT_CLASS_VAMPIRE_PORTAL)
									{
										EffectVampirePortal* pEffectVampirePortal = dynamic_cast<EffectVampirePortal*>(pEffect);
										ZONE_COORD zonecoord = pEffectVampirePortal->getZoneCoord();

										GCAddVampirePortal gcAddVampirePortal;
										gcAddVampirePortal.setObjectID(pEffect->getObjectID());
										gcAddVampirePortal.setOwnerID(pEffectVampirePortal->getOwnerID());
										gcAddVampirePortal.setX(ix);
										gcAddVampirePortal.setY(iy);
										gcAddVampirePortal.setTargetZoneID(zonecoord.id);
										gcAddVampirePortal.setTargetX(zonecoord.x);
										gcAddVampirePortal.setTargetY(zonecoord.y);
										gcAddVampirePortal.setDuration(pEffectVampirePortal->getRemainDuration());
										gcAddVampirePortal.setCreateFlag(0);

										pPlayer->sendPacket(&gcAddVampirePortal);
									}
									// by sigi. 2002.6.10
									else if (pEffect->getEffectClass() == Effect::EFFECT_CLASS_SANCTUARY)
									{
										EffectSanctuary* pEffectSanctuary = dynamic_cast<EffectSanctuary*>(pEffect);

										ZoneCoord_t centerX = pEffectSanctuary->getCenterX();
										ZoneCoord_t centerY = pEffectSanctuary->getCenterY();
										
										// sanctuary는 중심좌표인 경우만 packet을 보낸다.
										if (centerX==ix && centerY==iy)
										{
											GCAddEffectToTile gcAddEffectToTile;

											gcAddEffectToTile.setObjectID(pEffect->getObjectID());
											gcAddEffectToTile.setXY(ix, iy); 
											gcAddEffectToTile.setEffectID(pEffect->getEffectClass());
											gcAddEffectToTile.setDuration(pEffect->getRemainDuration());

											pPlayer->sendPacket(&gcAddEffectToTile);
										}
									}
									else
									{
										GCAddEffectToTile gcAddEffectToTile;

										gcAddEffectToTile.setObjectID(pEffect->getObjectID());
										gcAddEffectToTile.setXY(ix, iy); 
										gcAddEffectToTile.setEffectID(pEffect->getEffectClass());
										gcAddEffectToTile.setDuration(pEffect->getRemainDuration());
			
										pPlayer->sendPacket(&gcAddEffectToTile);
									}
								}
							}
							break;

						//--------------------------------------------------------------------------------
						// 타일 위에 장애물이 있을 경우
						//--------------------------------------------------------------------------------
						case Object::OBJECT_CLASS_OBSTACLE :
							{
								// darkness
							}
							break;

						//--------------------------------------------------------------------------------
						// 타일 위에 포탈이 있을 경우
						//--------------------------------------------------------------------------------
						case Object::OBJECT_CLASS_PORTAL :
							{
								// darkness
							}
							break;

						default :
							throw Error("invalid object class");

					}//switch ((*itr)->getObjectClass())
				} while ( ++itr != objectList.end() );	// do ~ while
			}//if
		}//for
	}//for

	SAFE_DELETE(pGCAddXXX);

	return true;
	
	__END_DEBUG 
	__END_CATCH
}

//////////////////////////////////////////////////////////////////////////////
// (x1,y1)에서 (x2,y2)로 PC가 이동할 경우, 그 PC가 자리가 바뀜에 따라
// 새로 보게 되는 것들에 대한 정보를 보내줘야 하고, 그 PC를 새로 보게 되는
// 다른 크리쳐들에게도 정보를 보내줘야 한다.
//
// bSendMove는 move packet을 보내는가에 대한 변수.
// bKnockback은 현재의 움직임이 정상적인 움직임인가, 아니면 knockback에
// 의한 강제적인 움직임인가를 나타내는 변수
//////////////////////////////////////////////////////////////////////////////
void Zone::movePCBroadcast (Creature* pPC, ZoneCoord_t x1, ZoneCoord_t y1, ZoneCoord_t x2, ZoneCoord_t y2, bool bSendMove, bool bKnockback)
	throw (ProtocolException, Error)
{
	__BEGIN_TRY

	// 이 메쏘드는 PC 를 대상으로 한다.
	Assert(pPC->isPC());

	//////////////////////////////////////////////////////////////////////////////
	// 자신의 이동을 나타내는 GCMove 패킷을 만들어둔다. 클라이언트에게 GCMove를 
	// 전송할때, (x,y)는 이전 좌표여야 하며, dir 은 바라보는(이동할) 방향이어야 한다.
	// 그것이 현재의 정책!
	//////////////////////////////////////////////////////////////////////////////
	GCMove gcMove;
	if (bSendMove)
	{
		gcMove.setObjectID(pPC->getObjectID());
		gcMove.setX(x1);
		gcMove.setY(y1);
		gcMove.setDir(pPC->getDir());
	}
	GCKnockBack gcKnockback;
	if (bKnockback)
	{
		gcKnockback.setObjectID(pPC->getObjectID());
		gcKnockback.setOrigin(x1, y1);
		gcKnockback.setTarget(x2, y2);
	}

	//////////////////////////////////////////////////////////////////////////////
	// 움직이는 PC를 새로 보게될 다른 PC들을 위해서 PC의 타입에 따라 GCAdd 패킷을
	// 만들어둔다.  현재의 정책에 의하면, GCAdd 패킷은 현재의 좌표를 바탕으로 한다.
	//////////////////////////////////////////////////////////////////////////////
	Packet* pGCAddXXX = NULL;

	if (pPC->getCreatureClass() == Creature::CREATURE_CLASS_SLAYER) 
	{
		Slayer* pSlayer = dynamic_cast<Slayer*>(pPC);
		GCAddSlayer* pGCAddSlayer = new GCAddSlayer(pSlayer->getSlayerInfo3());
		pGCAddSlayer->setEffectInfo(pSlayer->getEffectInfo());
		pGCAddXXX = pGCAddSlayer;
	} 
	else if (pPC->getCreatureClass() == Creature::CREATURE_CLASS_VAMPIRE) 
	{
		Vampire* pVampire = dynamic_cast<Vampire*>(pPC);

		// 음.. hide상태에서 움직일 수는 없지만. 미래를 대비.
		if (pPC->isFlag(Effect::EFFECT_CLASS_HIDE))
		{
			GCAddBurrowingCreature* pGCABC = new GCAddBurrowingCreature();
			pGCABC->setObjectID(pVampire->getObjectID());
			pGCABC->setName(pVampire->getName());
			pGCABC->setX(x2);
			pGCABC->setY(y2);
			pGCAddXXX = pGCABC;	
		}
		else
		{
			GCAddVampire* pGCAddVampire = new GCAddVampire(pVampire->getVampireInfo3());
			pGCAddVampire->setEffectInfo(pVampire->getEffectInfo());
			pGCAddXXX = pGCAddVampire;
		}
	}

	//////////////////////////////////////////////////////////////////////////////
	// PC가 움직이므로, 보고있던 놈들 중에서 이 PC를 못 보게
	// 되는 놈들도 있다. 이들에게 보내줄 GCDeleteObject 패킷을
	// 만들어둔다.
	//////////////////////////////////////////////////////////////////////////////
	GCDeleteObject gcDeleteObject;
	gcDeleteObject.setObjectID(pPC->getObjectID());

	Player* pPlayer = pPC->getPlayer();
	Assert(pPlayer != NULL);

	// loop 안에 있던걸 이쪽으로 뺐다. by sigi. 2002.5.8
	Sight_t sight = pPC->getSight();
	VisionInfo* pVisionInfo = g_pVisionInfoManager->getVisionInfo(sight, pPC->getDir());

    // Revealer 이펙트를 가져온다.
//	EffectRevealer* pEffectRevealer = NULL;
//	if ( pPC->isFlag(Effect::EFFECT_CLASS_REVEALER) )
//	{
//		pEffectRevealer = dynamic_cast<EffectRevealer*>(pPC->findEffect(Effect::EFFECT_CLASS_REVEALER));
//		Assert( pEffectRevealer != NULL );
//	}

	//////////////////////////////////////////////////////////////////////////////
	// 시야 영역의 상하좌우 모두 + 1 씩 증가시킨다. 
	// 이유는 방향에 따른 ON_SIGHT 영역이 증가되기 때문이다.
	//////////////////////////////////////////////////////////////////////////////
	for (ZoneCoord_t ix = max(0, x2 - maxViewportWidth - 1), endx = min(m_Width - 1, x2 + maxViewportWidth + 1) ; ix <= endx ; ix++) 
	{
		for (ZoneCoord_t iy = max(0, y2 - maxViewportUpperHeight - 1), endy = min(m_Height - 1, y2 + maxViewportLowerHeight + 1) ; iy <= endy ; iy++) 
		{
			//if (pPC->isFlag(Effect::EFFECT_CLASS_DARKNESS)) sight = DARKNESS_SIGHT;
			
			// 현재 타일 위에 있는 모든 오브젝트들에 대해 반복한다.
			const slist<Object*> & objectList = m_pTiles[ix][iy].getObjectList();
	
			slist<Object*>::const_iterator itr = objectList.begin();

			// 
			// object가 있는 경우만 
			// pVisionInfo->getVisionState()를 체크 하기 위해서
			// if - do~while 을 사용했다. by sigi. 2002.5.8
			//
			if (itr != objectList.end())
			{
				// 이전 좌표 P(x1,y1)에서 I(ix,iy)가 어떻게 보이는가?
				VisionState prevVisionState = pVisionInfo->getVisionState(x1,y1,ix,iy);
				// 현재 좌표 Q(x2,y2)에서 I(ix,iy)가 어떻게 보이는가?
				VisionState curVisionState = pVisionInfo->getVisionState(x2,y2,ix,iy);

				do		
				{
					Assert(*itr != NULL);

					Object::ObjectClass OClass = (*itr)->getObjectClass();

					////////////////////////////////////////////////////////////
					// 각 객체의 OBJECT CLASS에 따라서 적합한 GCAddXXX 패킷을
					// 만들어서 owner 에게 전송한다. 
					////////////////////////////////////////////////////////////
					
					////////////////////////////////////////////////////////////
					// 타일 위에 크리처가 있을 경우
					////////////////////////////////////////////////////////////
					if (OClass == Object::OBJECT_CLASS_CREATURE)
					{
						Creature* pCreature = dynamic_cast<Creature*>(*itr);
						Assert(pCreature != NULL);

						if (pCreature == pPC)
						{
							// 넉백일 경우, 자신의 의지에 의해 움직이는 것이 아니라, 
							// 타인에 의해 움직이는 것이므로 보내줘야 한다.
							if (bKnockback)
							{
								pPC->getPlayer()->sendPacket(&gcKnockback);
								// 넉백을 보내줬으면 continue한다.
							}

							// 자기 자신의 이동 정보는 받을 필요가 없다.
							continue;
						}

						Creature::CreatureClass CClass = pCreature->getCreatureClass();

						// Monster > Slayer > Vampire > NPC 순이라고 판단해서
						// if 순서를 바꿨다. 길드 건물 같은 곳은 좀 다르겠지만?
						// by sigi. 2002.5.8
						if (CClass == Creature::CREATURE_CLASS_MONSTER)
						{
							Monster* pMonster = dynamic_cast<Monster*>(pCreature);

							//--------------------------------------------------------------------------------
							// 이전 좌표에서는 이 몬스터를 볼 수 없었으나, 도착 좌표에서 이 몬스터를 보게 될
							// 경우 GCAddMonster 패킷을 전송한다.
							//--------------------------------------------------------------------------------
							if (prevVisionState == OUT_OF_SIGHT && curVisionState >= ON_SIGHT) 
							{											
								// by sigi
								Packet* pAddMonsterPacket = createMonsterAddPacket( pMonster, pPC );

								if (pAddMonsterPacket!=NULL)
								{
									pPlayer->sendPacket( pAddMonsterPacket );

									delete pAddMonsterPacket;
								}
							}

							// PC를 몬스터의 잠재적인 적으로 지정해준다.
							VisionState vs = pMonster->getVisionState(x2,y2);

							// Aggressive 몬스터에게만 적으로 등록시켜준다.
							if (vs >= IN_SIGHT && pMonster->getAlignment() == ALIGNMENT_AGGRESSIVE) 
							{
								if (isPotentialEnemy(pMonster, pPC))
								{
									pMonster->addPotentialEnemy(pPC);
								}
							}
						}
						else if (CClass == Creature::CREATURE_CLASS_SLAYER)
						{
							// 현재 타일이 원래는 안 보이다가 이제 보이는 경우에, 
							// 이 타일에 크리쳐가 서 있다면... 
							// 움직이고 있는 PC에게 이 타일에 서 있는 놈의 정보를 보내주어야 한다.
							if (curVisionState >= IN_SIGHT && prevVisionState == OUT_OF_SIGHT) 
							{
								// 현재 움직이는 크리쳐에게 스나이핑 상태가 걸려있지 않거나,
								// 걸려있다면 디텍트 인비저빌러티가 걸려있어야 볼 수 있다.
								//if (!pPC->isFlag(Effect::EFFECT_CLASS_SNIPING_MODE) || pCreature->isFlag(Effect::EFFECT_CLASS_DETECT_INVISIBILITY)) 
								if (!pCreature->isFlag(Effect::EFFECT_CLASS_SNIPING_MODE) || pPC->isFlag(Effect::EFFECT_CLASS_DETECT_INVISIBILITY) ) // || ( pEffectRevealer != NULL && pEffectRevealer->canSeeSniping( pCreature ) ) ) 
								{
									Slayer* pSlayer = dynamic_cast<Slayer*>(pCreature);
									GCAddSlayer gcAddSlayer(pSlayer->getSlayerInfo3()); 
									gcAddSlayer.setEffectInfo(pSlayer->getEffectInfo());
									pPlayer->sendPacket(&gcAddSlayer);
								}
							}

							Assert(pCreature->getPlayer() != NULL);

							//////////////////////////////////////////////////////////////////////////////
							// Q(x2,y2)가 이 크리처의 시야 사각형의 경계에 위치하면서, P(x1,y1)은 사각형의 외부, 
							// 즉 보이지 않는 경우에만 GCAddXXX 패킷을 전송한다. 이렇게 하지 않으면, PC
							// 크리처가 pCreature의 시야 경계에서 계속 움직이게 되면 계속 서버는 GCAddXXX 패킷을
							// 보내야만 한다.
							//
							// 요약하면,
							//
							// OUT_OF_SIGHT -> ON_SIGHT/NEW_SIGHT : GCAddXXX 
							// IN_SIGHT/ON_SIGHT/NEW_SIGHT -> IN_SIGHT/ON_SIGHT/NEW_SIGHT : GCMove
							//////////////////////////////////////////////////////////////////////////////
							VisionState prevVS = pCreature->getVisionState(x1,y1);
							VisionState currVS = pCreature->getVisionState(x2,y2);

							// 보이지 않는 영역에서, 경계 영역을 거치지 않고 바로
							// 시야 내부 영역으로 들어온다는 것은 불가능하다.
							Assert(prevVS != OUT_OF_SIGHT || currVS != IN_SIGHT);

							// Revealer 이펙트를 가져온다.
//							EffectRevealer* pEffectRevealerCreature = NULL;
//							if ( pCreature->isFlag( Effect::EFFECT_CLASS_REVEALER ) )
//							{
//								pEffectRevealerCreature = dynamic_cast<EffectRevealer*>( pCreature->findEffect( Effect::EFFECT_CLASS_REVEALER ) );
//								Assert( pEffectRevealerCreature );
//							}

							// 상대에게 PC의 등장을 알리는 패킷.
							// 여기 밑에도 &&가 아니라 || 아닐까? 경환? /by elca
							if ((!pPC->isFlag(Effect::EFFECT_CLASS_HIDE) || pCreature->isFlag(Effect::EFFECT_CLASS_DETECT_HIDDEN) )// || ( pEffectRevealerCreature != NULL && pEffectRevealerCreature->canSeeHide( pPC ) ) ) && 
								&& (!pPC->isFlag(Effect::EFFECT_CLASS_INVISIBILITY) || pCreature->isFlag(Effect::EFFECT_CLASS_DETECT_INVISIBILITY) ) //|| ( pEffectRevealerCreature != NULL && pEffectRevealerCreature->canSeeInvisibility( pPC ) ) ) && 
								&& (!pPC->isFlag(Effect::EFFECT_CLASS_SNIPING_MODE) || pCreature->isFlag(Effect::EFFECT_CLASS_DETECT_INVISIBILITY) ) )//|| ( pEffectRevealerCreature != NULL && pEffectRevealerCreature->canSeeSniping( pPC ) ) ))
							{
								if (prevVS == OUT_OF_SIGHT && currVS >= ON_SIGHT) 
								{
									pCreature->getPlayer()->sendPacket(pGCAddXXX);
								} 
								else if (prevVS >= IN_SIGHT && currVS >= IN_SIGHT) 
								{
									if (bSendMove)
										pCreature->getPlayer()->sendPacket(&gcMove);
									else if (bKnockback)
										pCreature->getPlayer()->sendPacket(&gcKnockback);
								}
								else if (prevVS >= IN_SIGHT && currVS == OUT_OF_SIGHT)
								{
									pCreature->getPlayer()->sendPacket(&gcDeleteObject);
								}
							}
						}
						else if (CClass == Creature::CREATURE_CLASS_VAMPIRE)
						{
							//////////////////////////////////////////////////////////////////////////////
							// 이전 좌표에서는 보이지 않다가, 이번 좌표에서 새로 보이게 된 크리처만
							// GCAddXXX 를 받아온다. 이전에도 NEW_SIGHT 이고, 지금도 NEW_SIGHT 이면,
							// 새로 받아오지 않는다.
							//////////////////////////////////////////////////////////////////////////////
							if (curVisionState == NEW_SIGHT && prevVisionState == OUT_OF_SIGHT) 
							{
								if (pCreature->isFlag(Effect::EFFECT_CLASS_HIDE)) 
								{
									if (pPC->isVampire() || pPC->isFlag(Effect::EFFECT_CLASS_DETECT_HIDDEN) )// || ( pEffectRevealer != NULL && pEffectRevealer->canSeeHide( pCreature ) ) ) 
									{
										GCAddBurrowingCreature gcABC;
										gcABC.setObjectID(pCreature->getObjectID());
										gcABC.setName(pCreature->getName());
										gcABC.setX(ix);
										gcABC.setY(iy);
										pPlayer->sendPacket(&gcABC);
									}
								} 
								else 
								{
									if (!pCreature->isFlag(Effect::EFFECT_CLASS_INVISIBILITY))
									{
										Vampire* pVampire = dynamic_cast<Vampire*>(pCreature);
										GCAddVampire gcAddVampire(pVampire->getVampireInfo3());
										gcAddVampire.setEffectInfo(pVampire->getEffectInfo());
										pPlayer->sendPacket(&gcAddVampire);
									}
									// pCreature는 invisibility상태..
									else if (pPC->isVampire() || pPC->isFlag(Effect::EFFECT_CLASS_DETECT_INVISIBILITY) ) //|| ( pEffectRevealer != NULL && pEffectRevealer->canSeeInvisibility( pCreature ) ) )
									{
										// FIXME
										// 설정에따라서 어떻게 보일지 결정된 후..
										//
										Vampire* pVampire = dynamic_cast<Vampire*>(pCreature);
										GCAddVampire gcAddVampire(pVampire->getVampireInfo3());
										gcAddVampire.setEffectInfo(pVampire->getEffectInfo());
										pPlayer->sendPacket(&gcAddVampire);
									}
								}
							}

							Assert(pCreature->getPlayer() != NULL);

							//////////////////////////////////////////////////////////////////////////////
							// Q(x2,y2)가 이 크리처의 시야 사각형의 경계에 위치하면서, P(x1,y1)은 사각형의 외부, 
							// 즉 보이지 않는 경우에만 GCAddXXX 패킷을 전송한다. 이렇게 하지 않으면, PC
							// 크리처가 pCreature의 시야 경계에서 계속 움직이게 되면 계속 서버는 GCAddXXX 패킷을
							// 보내야만 한다.
							//
							// 요약하면,
							//
							// OUT_OF_SIGHT -> ON_SIGHT/NEW_SIGHT : GCAddXXX 
							// IN_SIGHT/ON_SIGHT/NEW_SIGHT -> IN_SIGHT/ON_SIGHT/NEW_SIGHT : GCMove
							//////////////////////////////////////////////////////////////////////////////
							VisionState prevVS = pCreature->getVisionState(x1,y1);
							VisionState currVS = pCreature->getVisionState(x2,y2);

							// 보이지 않는 영역에서, 경계 영역을 거치지 않고 바로
							// 시야 내부 영역으로 들어온다는 것은 불가능하다.
							Assert(prevVS != OUT_OF_SIGHT || currVS != IN_SIGHT);

							// 상대는 뱀파이어이므로 나의 darkness상태는 관계없다.
							// Hide도 관계없다.
							if (!pPC->isSlayer() || !pPC->isFlag(Effect::EFFECT_CLASS_SNIPING_MODE)) 
							{
								if (prevVS == OUT_OF_SIGHT && currVS >= ON_SIGHT) 
								{
									pCreature->getPlayer()->sendPacket(pGCAddXXX);
								}
								else if (prevVS >= IN_SIGHT && currVS >= IN_SIGHT) 
								{
									if (bSendMove) pCreature->getPlayer()->sendPacket(&gcMove);
									else if (bKnockback) pCreature->getPlayer()->sendPacket(&gcKnockback);
								}
								else if (prevVS >= IN_SIGHT && currVS == OUT_OF_SIGHT)
								{
									pCreature->getPlayer()->sendPacket(&gcDeleteObject);
								}
							}
						}
						
						else if (CClass == Creature::CREATURE_CLASS_NPC)
						{
							NPC* pNPC = dynamic_cast<NPC*>(pCreature);

							//--------------------------------------------------------------------------------
							//
							// 이전 좌표에서는 이 몬스터를 볼 수 없었으나, 도착 좌표에서 이 몬스터를 보게 될
							// 경우 GCAddMonster 패킷을 전송한다.
							//
							//--------------------------------------------------------------------------------
							if (prevVisionState == OUT_OF_SIGHT && curVisionState >= ON_SIGHT) 
							{
								GCAddNPC gcAddNPC;
								makeGCAddNPC(&gcAddNPC, pNPC);
								pPlayer->sendPacket(&gcAddNPC);
							}
						}
						else 
						{
							throw Error("invalid creature class");
						}
					}
					////////////////////////////////////////////////////////////
					// 타일 위에 아이템이 있을 경우
					////////////////////////////////////////////////////////////
					else if (OClass == Object::OBJECT_CLASS_ITEM)
					{
						if (curVisionState >= IN_SIGHT && prevVisionState == OUT_OF_SIGHT)
						{
							Item* pItem = dynamic_cast<Item*>(*itr);

							Item::ItemClass IClass = pItem->getItemClass();

							if (IClass == Item::ITEM_CLASS_CORPSE)
							{
								ItemType_t IType = pItem->getItemType();

								if (IType == SLAYER_CORPSE)
								{
									SlayerCorpse* pSlayerCorpse = dynamic_cast<SlayerCorpse*>(pItem);
									GCAddSlayerCorpse gcAddSlayerCorpse;
									makeGCAddSlayerCorpse(&gcAddSlayerCorpse, pSlayerCorpse);
									pPlayer->sendPacket(&gcAddSlayerCorpse);
								}
								else if (IType == VAMPIRE_CORPSE)
								{
									VampireCorpse* pVampireCorpse = dynamic_cast<VampireCorpse*>(pItem);
									GCAddVampireCorpse gcAddVampireCorpse;
									makeGCAddVampireCorpse(&gcAddVampireCorpse, pVampireCorpse);
									pPlayer->sendPacket(&gcAddVampireCorpse);
								}
								else if (IType == NPC_CORPSE)
								{
									throw UnsupportedError();
								}
								else if (MONSTER_CORPSE)
								{
									MonsterCorpse* pMonsterCorpse = dynamic_cast<MonsterCorpse*>(pItem);
									GCAddMonsterCorpse gcAddMonsterCorpse;
									makeGCAddMonsterCorpse(&gcAddMonsterCorpse, pMonsterCorpse, ix, iy);
									pPlayer->sendPacket(&gcAddMonsterCorpse);
								}
								else
								{
									Assert(false);
								}
							} 
							else if (pItem->getItemClass() == Item::ITEM_CLASS_MINE && pItem->isFlag(Effect::EFFECT_CLASS_INSTALL))
							{	
								if (pPC->isFlag(Effect::EFFECT_CLASS_REVEALER) )
								{
									GCAddInstalledMineToZone gcAddMine;
									gcAddMine.setObjectID(pItem->getObjectID());
									gcAddMine.setX(ix);
									gcAddMine.setY(iy);
									gcAddMine.setItemClass(pItem->getItemClass());
									gcAddMine.setItemType(pItem->getItemType());
									gcAddMine.setOptionType(pItem->getOptionType());
									gcAddMine.setDurability(pItem->getDurability());
									pPlayer->sendPacket(&gcAddMine);
								} 
							}
							else 
							{
								GCAddNewItemToZone gcAddNewItemToZone;
								makeGCAddNewItemToZone(&gcAddNewItemToZone, pItem, ix, iy);
								pPlayer->sendPacket(&gcAddNewItemToZone);
							}
						}
					}
					////////////////////////////////////////////////////////////
					// 타일 위에 이펙트가 있을 경우
					////////////////////////////////////////////////////////////
					else if (OClass == Object::OBJECT_CLASS_EFFECT)
					{
						Effect* pEffect = dynamic_cast<Effect*>(*itr);
						
						if (curVisionState >= IN_SIGHT && prevVisionState == OUT_OF_SIGHT)
						{
							if (pEffect->getEffectClass() == Effect::EFFECT_CLASS_VAMPIRE_PORTAL)
							{
								EffectVampirePortal* pEffectVampirePortal = dynamic_cast<EffectVampirePortal*>(pEffect);
								ZONE_COORD zonecoord = pEffectVampirePortal->getZoneCoord();

								GCAddVampirePortal gcAddVampirePortal;
								gcAddVampirePortal.setObjectID(pEffect->getObjectID());
								gcAddVampirePortal.setOwnerID(pEffectVampirePortal->getOwnerID());
								gcAddVampirePortal.setX(ix);
								gcAddVampirePortal.setY(iy);
								gcAddVampirePortal.setTargetZoneID(zonecoord.id);
								gcAddVampirePortal.setTargetX(zonecoord.x);
								gcAddVampirePortal.setTargetY(zonecoord.y);
								gcAddVampirePortal.setDuration(pEffectVampirePortal->getRemainDuration());
								gcAddVampirePortal.setCreateFlag(0);

								pPlayer->sendPacket(&gcAddVampirePortal);
							}
							// by sigi. 2002.6.10
							else if (pEffect->getEffectClass() == Effect::EFFECT_CLASS_SANCTUARY)
							{
								EffectSanctuary* pEffectSanctuary = dynamic_cast<EffectSanctuary*>(pEffect);

								ZoneCoord_t centerX = pEffectSanctuary->getCenterX();
								ZoneCoord_t centerY = pEffectSanctuary->getCenterY();
								
								// sanctuary는 중심좌표인 경우만 packet을 보낸다.
								if (centerX==ix && centerY==iy)
								{
									GCAddEffectToTile gcAddEffectToTile;

									gcAddEffectToTile.setObjectID(pEffect->getObjectID());
									gcAddEffectToTile.setXY(ix, iy); 
									gcAddEffectToTile.setEffectID(pEffect->getEffectClass());
									gcAddEffectToTile.setDuration(pEffect->getRemainDuration());

									pPlayer->sendPacket(&gcAddEffectToTile);
								}
							}
							else
							{
								GCAddEffectToTile gcAddEffectToTile;

								gcAddEffectToTile.setObjectID(pEffect->getObjectID());
								gcAddEffectToTile.setXY(ix, iy); 
								gcAddEffectToTile.setEffectID(pEffect->getEffectClass());
								gcAddEffectToTile.setDuration(pEffect->getRemainDuration());

								pPlayer->sendPacket(&gcAddEffectToTile);
							}
						}
					}
					////////////////////////////////////////////////////////////
					// 타일 위에 장애물이 있을 경우
					////////////////////////////////////////////////////////////
					else if (OClass == Object::OBJECT_CLASS_OBSTACLE)
					{
					}
					////////////////////////////////////////////////////////////
					// 타일 위에 포탈이 있을 경우
					////////////////////////////////////////////////////////////
					else if (OClass == Object::OBJECT_CLASS_PORTAL)
					{
						// darkness
					}
					else
					{
						throw Error("invalid object class");
					}

				} while ( ++itr != objectList.end() );	// by sigi. 2002.5.8
			}//for 오브젝트들에 대한 반복
		}//for Y 좌표에 대한 반복
	}//for X 좌표에 대한 반복

	SAFE_DELETE(pGCAddXXX);

	__END_CATCH
}


//////////////////////////////////////////////////////////////////////////////
// moveCreatureBroadcast
//
// PC가 아닌 크리처(NPC,몬스터)가 P(x1,y1)에서 Q(x2,y2)로 이동했을 때,
// 주변 영역에 존재하는 PC들에게 브로드캐스트하는 메쏘드이다.
//
// 이 메쏘드를 호출하기 전에, 3 가지 패킷은 만들어둬야만 한다.
//////////////////////////////////////////////////////////////////////////////
void Zone::moveCreatureBroadcast(Creature* pCreature, ZoneCoord_t x1, ZoneCoord_t y1, ZoneCoord_t x2, ZoneCoord_t y2, bool bSendMove, bool bKnockback)
	throw(ProtocolException, Error)
{
	__BEGIN_TRY

	Monster* pMonster = NULL;
	NPC* pNPC = NULL;

	Assert(pCreature != NULL);
	Assert(pCreature->isNPC() || pCreature->isMonster());

	// 현재의 정책에 의하면, GCMove 패킷은 이전 좌표와 현재 방향을 전송하게 되어있다.
	GCMove gcMove;
	if (bSendMove)
	{
		gcMove.setObjectID(pCreature->getObjectID());
		gcMove.setX(x1);
		gcMove.setY(y1);
		gcMove.setDir(pCreature->getDir());
	}
	GCKnockBack gcKnockback;
	if (bKnockback)
	{
		gcKnockback.setObjectID(pCreature->getObjectID());
		gcKnockback.setOrigin(x1, y1);
		gcKnockback.setTarget(x2, y2);
	}

	// GCAddNPC/GCAddMonster 패킷을 만들어둔다.
	Packet* pGCAddXXX = NULL;

	bool isMonster = !pCreature->isNPC();
	bool isMonsterHide = false;
	bool isMonsterInvisibility = false;

	if (!isMonster)
	{
		pNPC = dynamic_cast<NPC*>(pCreature);
		GCAddNPC* pGCAddNPC = new GCAddNPC();
		makeGCAddNPC(pGCAddNPC, pNPC);
		pGCAddXXX = pGCAddNPC;
	} 
	else // case of Monster
	{ 
		pMonster = dynamic_cast<Monster*>(pCreature);

		// 일단 다 볼 수 있는 상태(NULL)로 설정해서 packet을 생성한다. by sigi
		pGCAddXXX = createMonsterAddPacket( pMonster, NULL );

		// monster의 상태를 기억해둔다.
		isMonsterHide = pMonster->isFlag(Effect::EFFECT_CLASS_HIDE);
		isMonsterInvisibility = pMonster->isFlag(Effect::EFFECT_CLASS_INVISIBILITY);
	}

	// 시야에서 벗어날 때, GCDeleteObject 패킷을 보낸다.
	GCDeleteObject gcDeleteObject;
	gcDeleteObject.setObjectID(pCreature->getObjectID());

	//////////////////////////////////////////////////////////////////////////////
	// 시야 영역의 상하좌우 모두 + 1 씩 증가시킨다. 
	// 이유는 방향에 따른 ON_SIGHT 영역이 증가되기 때문이다.
	//////////////////////////////////////////////////////////////////////////////
	for (ZoneCoord_t ix = max(0, x2 - maxViewportWidth - 1), endx = min(m_Width - 1, x2 + maxViewportWidth + 1) ; ix <= endx ; ix++) 
	{
		for (ZoneCoord_t iy = max(0, y2 - maxViewportUpperHeight - 1), endy = min(m_Height - 1, y2 + maxViewportLowerHeight + 1) ; iy <= endy ; iy++) 
		{
			const slist<Object*> & objectList = m_pTiles[ix][iy].getObjectList();
			slist<Object*>::const_iterator itr = objectList.begin();
			for (; itr != objectList.end() && (*itr)->getObjectPriority() <= OBJECT_PRIORITY_BURROWING_CREATURE; itr++) 
			{
				Assert(*itr != NULL);

				Creature* pPC = dynamic_cast<Creature*>(*itr);

				Assert(pPC != NULL);

				// PC 일 경우에만 GCMove, GCAddMonster 패킷을 보내준다. 몬스터한테는 보낼 필요가 없쥐~
				if (pPC->isPC()) 
				{
					Assert(pPC->getPlayer() != NULL);

					//////////////////////////////////////////////////////////////////////////////
					// OUT_OF_SIGHT -> ON_SIGHT/NEW_SIGHT : GCAddXXX 
					// IN_SIGHT/ON_SIGHT/NEW_SIGHT -> IN_SIGHT/ON_SIGHT/NEW_SIGHT : GCMove
					//////////////////////////////////////////////////////////////////////////////
					VisionState prevVS = pPC->getVisionState(x1,y1);
					VisionState currVS = pPC->getVisionState(x2,y2);

					// 보이지 않는 영역에서, 경계 영역을 거치지 않고 바로
					// 시야 내부 영역으로 들어온다는 것은 불가능하다.
					Assert(prevVS != OUT_OF_SIGHT || currVS != IN_SIGHT);

					// Revealer 이펙트를 가져온다.
//					EffectRevealer* pEffectRevealer = NULL;
//					if ( pPC->isFlag( Effect::EFFECT_CLASS_REVEALER ) )
//					{
//						pEffectRevealer = dynamic_cast<EffectRevealer*>(pPC->findEffect(Effect::EFFECT_CLASS_REVEALER));
//						Assert( pEffectRevealer );
//					}

					if (prevVS == OUT_OF_SIGHT && currVS >= ON_SIGHT) 
					{
						if (isMonster)
						{
							if (isMonsterHide)
							{
								if (pPC->isVampire() || pPC->isFlag(Effect::EFFECT_CLASS_DETECT_INVISIBILITY) )// || ( pEffectRevealer != NULL && pEffectRevealer->canSeeHide( pMonster ) ) )
								{
									pPC->getPlayer()->sendPacket(pGCAddXXX);
								}
							}
							else if (isMonsterInvisibility)
							{
								if (pPC->isVampire() || pPC->isFlag(Effect::EFFECT_CLASS_DETECT_HIDDEN) )// || ( pEffectRevealer != NULL && pEffectRevealer->canSeeInvisibility( pMonster ) ) )
								{
									pPC->getPlayer()->sendPacket(pGCAddXXX);
								}
							}
							else
							{
								pPC->getPlayer()->sendPacket(pGCAddXXX);
							}
						}
						else
						{
							pPC->getPlayer()->sendPacket(pGCAddXXX);
						}
					} 
					else if (prevVS >= IN_SIGHT && currVS >= IN_SIGHT) 
					{
						if (bSendMove)
						{
							pPC->getPlayer()->sendPacket(&gcMove);
						}
						else if (bKnockback)
						{
							pPC->getPlayer()->sendPacket(&gcKnockback);
						}
					} 
					else if (prevVS >= IN_SIGHT && currVS == OUT_OF_SIGHT) 
					{
						pPC->getPlayer()->sendPacket(&gcDeleteObject);
					}

					//--------------------------------------------------------------------------------
					// 브로드캐스트를 했으면, 이제 이 PC를 잠재적인 적으로 등록해버리자.
					//--------------------------------------------------------------------------------
					if (pCreature->isMonster())
					{
						// 저 위에서 이미 dynamic_cast 된 상태이다.
						VisionState vs = pMonster->getVisionState(ix,iy);
						if (vs >= IN_SIGHT && pMonster->getAlignment() == ALIGNMENT_AGGRESSIVE) 
						{
							if (isPotentialEnemy(pMonster, pPC))
							{
								pMonster->addPotentialEnemy(pPC);
							}
						}
					}
					
				}//if

			}//for

		}//for

	}//for

	// 생성한 패킷을 삭제한다.
	SAFE_DELETE(pGCAddXXX);

	__END_CATCH
}

//////////////////////////////////////////////////////////////////////////////
// 일정 주기마다 해줘야 하는 기능들을 여기에 추가하도록 한다.
//////////////////////////////////////////////////////////////////////////////
void Zone::heartbeat ()
	throw(Error)
{
	__BEGIN_TRY
	__BEGIN_DEBUG

	try
	{
		__ENTER_CRITICAL_SECTION(m_Mutex)

		beginProfileEx("Z_PCQUEUE");

		// PCQueue의 PC를 존에 추가한다.	
		while(! m_PCListQueue.empty()) 
		{
			Creature* pCreature = m_PCListQueue.front();
			Assert(pCreature != NULL);
			Assert(pCreature->getZone() == this);

			// 존에 추가하고, 주변 PC들에게 브로드캐스트한다.
			addPC(pCreature, pCreature->getX(), pCreature->getY(), DOWN);

			m_PCListQueue.pop_front();
		}

		endProfileEx("Z_PCQUEUE");

		beginProfileEx("Z_PC");
		m_pPCManager->processCreatures(); // process all PC
		endProfileEx("Z_PC");

		// player가 있어야 monster를 heartbeat한다.
		// 즉, player가 없는 zone은 monster가 가만히 있는다.
		// monster의 EffectManager가 안 돌아가므로 문제가 될 수도 있지만,
		// 크게 문제가 없다고 보고.. -_-; .. by sigi. 2002.5.6
		//if ( m_ZoneID >= 1121 && m_ZoneID <= 1124)
		//	m_pCombatMonsterManager->processCreatures(); // 전투용 몬스터의 AI를 처리하는 부분, 김경석
		//else
		//{
			if (getPCCount() > 0)
			{
				beginProfileEx("Z_MONSTER");
				m_pMonsterManager->processCreatures(); // process all monsters
				endProfileEx("Z_MONSTER");
			}

			m_pEventMonsterManager->processCreatures();
		//}

		m_pCombatMonsterManager->processCreatures(); // 전투용 몬스터의 AI를 처리하는 부분, 김경석

		beginProfileEx("Z_NPC");
		m_pNPCManager->processCreatures(); // process all npcs
		endProfileEx("Z_NPC");

		beginProfileEx("Z_ESCH");
		// 먼저 이펙트 스케쥴을 먼저 실행시킨다.
		m_pEffectScheduleManager->heartbeat();
		endProfileEx("Z_ESCH");

		// Delete expired effects
		beginProfileEx("Z_EFFECT");
		m_pVampirePortalManager->heartbeat();

		__ENTER_CRITICAL_SECTION(m_MutexEffect)
		m_pLockedEffectManager->heartbeat();
		__LEAVE_CRITICAL_SECTION(m_MutexEffect)

		m_pEffectManager->heartbeat();

		endProfileEx("Z_EFFECT");

		beginProfileEx("Z_WEATHER");
		// weather changing...
		m_pWeatherManager->heartbeat();
		endProfileEx("Z_WEATHER");

		beginProfileEx("Z_ITEM");
		// item heartbeaet
		int i = 0;

		// Item의 EffectManager에서 getCurrentTime을 호출하지 않게 하기 위해서.
		// by sigi. 2002.5.8
		Timeval currentTime;
	    getCurrentTime(currentTime);

		for (hash_map<ObjectID_t, Item*>::iterator itr = m_Items.begin(); itr != m_Items.end() ; itr++)
		{
			Item* pItem = itr->second;
			Assert(pItem != NULL);
			EffectManager& rEffectManager = pItem->getEffectManager();
			rEffectManager.heartbeat(currentTime);
			i++;
		}

		endProfileEx("Z_ITEM");

		beginProfileEx("Z_PARTY");
		// party heartbeat
		m_pLocalPartyManager->heartbeat();
		endProfileEx("Z_PARTY");

		__LEAVE_CRITICAL_SECTION(m_Mutex)
	}
	catch (Throwable & t)
	{
		filelog("ZoneBug.txt", "%s : %s", "Zone::heartbeat(2)", t.toString().c_str());
		cerr << t.toString() << endl;
		throw;
	}

	__END_DEBUG
	__END_CATCH
}

//////////////////////////////////////////////////////////////////////////////
// PCManager, MonsterManager, NPCManager 에서 지정된 OID 를 가진 크리처를
// 찾아서 리턴한다. 없을 경우 NoSuchElementException 을 던진다.
//
// 이 메쏘드는 찾고자 하는 크리처의 타입(PC,NPC,Monster)를 모를 경우에
// 사용한다. 웬만하면, 타입을 알아내서 getCreature(Creature::CreatureClass,ObjectID_t) 
// 메쏘드를 사용하도록 한다.
//////////////////////////////////////////////////////////////////////////////
Creature* Zone::getCreature(ObjectID_t objectID) const
	throw()//NoSuchElementException, Error)
{
	__BEGIN_TRY

	// NoSuchElementException을 안 쓰는 버전 by sigi. 2002.5.2
	Creature* pCreature = NULL;

	pCreature = m_pMonsterManager->getCreature(objectID);

	if (pCreature==NULL)
	{
		pCreature = m_pPCManager->getCreature(objectID);

		if (pCreature==NULL)
		{
			pCreature = m_pNPCManager->getCreature(objectID);

			if (pCreature==NULL)
			{
				pCreature = m_pEventMonsterManager->getCreature(objectID);

				if(pCreature == NULL) pCreature = m_pCombatMonsterManager->getCreature(objectID);

			}

		}
	}

	return pCreature;

	/*
	try 
	{
		return m_pMonsterManager->getCreature(objectID);
	} 
	catch (NoSuchElementException) 
	{
		// not exist? go next
	} 
	*/

/*
//#ifdef __XMAS_EVENT_CODE__
	try 
	{
		return m_pEventMonsterManager->getCreature(objectID);
	} 
	catch (NoSuchElementException) 
	{
		// not exist? go next
	} 
//#endif
*/
	/*
	try 
	{
		return m_pPCManager->getCreature(objectID);
	} 
	catch (NoSuchElementException) 
	{
		// not exist? go next
	} 

	try 
	{
		return m_pNPCManager->getCreature(objectID);
	} 
	catch (NoSuchElementException) 
	{
		throw;
	}
	*/

	__END_CATCH
}

//////////////////////////////////////////////////////////////////////////////
// PCManager, MonsterManager, NPCManager 에서 지정된 Name을 가진 크리처를 찾아서
// 리턴한다. 없을 경우 NoSuchElementException 을 던진다.
//
// 이 메쏘드는 찾고자 하는 크리처의 타입(PC,NPC,Monster)를 모를 경우에 사용한다.
// 웬만하면, 타입을 알아내서 getCreature(Creature::CreatureClass,Name) 
// 메쏘드를 사용하도록 한다.
//////////////////////////////////////////////////////////////////////////////
Creature* Zone::getCreature(const string& Name) const
	throw()//NoSuchElementException, Error)
{
	__BEGIN_TRY

	// NoSuchElementException을 안 쓰는 버전 by sigi. 2002.5.2
	Creature* pCreature = NULL;

	pCreature = m_pPCManager->getCreature(Name);

	if (pCreature==NULL)
	{
		pCreature = m_pMonsterManager->getCreature(Name);

		if (pCreature==NULL)
		{
			pCreature = m_pNPCManager->getCreature(Name);

			if(pCreature==NULL)
			{
				pCreature = m_pEventMonsterManager->getCreature(Name);

				if(pCreature == NULL) pCreature = m_pCombatMonsterManager->getCreature(Name);

			}
		}

		
	}

	return pCreature;

	/*
	try 
	{
		return m_pPCManager->getCreature(Name);
	} 
	catch (NoSuchElementException) 
	{
		// not exist? go next
	} 

	try 
	{
		return m_pMonsterManager->getCreature(Name);
	} 
	catch (NoSuchElementException) 
	{
		// not exist? go next
	} 
	*/

/*
#ifdef __XMAS_EVENT_CODE__
	try 
	{
		return m_pEventMonsterManager->getCreature(Name);
	} 
	catch (NoSuchElementException) 
	{
		// not exist? go next
	} 
#endif
*/

	/*
	try 
	{
		return m_pNPCManager->getCreature(Name);
	} 
	catch (NoSuchElementException) 
	{
		throw;
	}
	*/

	__END_CATCH
}

//--------------------------------------------------------------------------------
//
// 존에서 특정 OID를 가진 특정 크리처 타입을 가진 크리처를 찾아서 리턴한다.
//
//--------------------------------------------------------------------------------
Creature* Zone::getCreature(Creature::CreatureClass creatureClass, ObjectID_t objectID) const
	throw(NoSuchElementException, Error)
{
	__BEGIN_TRY

	if (creatureClass == Creature::CREATURE_CLASS_SLAYER)
	{
		return m_pPCManager->getCreature(objectID);
	}
	else if (creatureClass == Creature::CREATURE_CLASS_VAMPIRE)
	{
		return m_pPCManager->getCreature(objectID);
	}
	else if (creatureClass == Creature::CREATURE_CLASS_NPC)
	{
		return m_pNPCManager->getCreature(objectID);
	}
	else if (creatureClass == Creature::CREATURE_CLASS_MONSTER)
	{
		return m_pMonsterManager->getCreature(objectID);
	}
/*
#ifdef __XMAS_EVENT_CODE__
		try
		{
			return m_pMonsterManager->getCreature(objectID);
		}
		catch (NoSuchElementException& nsee)
		{
		}

		return m_pEventMonsterManager->getCreature(objectID);
#else
*/
/*
#endif
*/

	return NULL; // evade warning.

	__END_CATCH
}

//////////////////////////////////////////////////////////////////////////////
// get debug string
//////////////////////////////////////////////////////////////////////////////
string Zone::toString () const
	throw ()
{
	__BEGIN_TRY

	StringStream msg;

	msg << "Zone("
		<< "ZoneID:"          << (int)m_ZoneID
		<< ",ZoneGroupID:"    << (int)m_pZoneGroup->getZoneGroupID() 
		<< ",ZoneType:"       << (int)m_ZoneType
		<< ",ZoneLevel:"      << (int)m_ZoneLevel
		<< ",ZoneAccessMode:" << (int)m_ZoneAccessMode
		<< ",OwnerID:"        << m_OwnerID
		<< ",DarkLevel:"      << (int)m_DarkLevel
		<< ",LightLevel:"     << (int)m_LightLevel
		<< ",WeatherManager:" << m_pWeatherManager->toString();

	msg << ",#NPC:" << (int)m_NPCCount;
	for (uint i = 0 ; i < m_NPCCount ; i++)
		msg << ",NPC[" << i << "] : " << (int)m_NPCTypes[i];

	msg << ",#Monster:" << (int)m_MonsterCount;

	Assert( m_MonsterCount < maxMonsterPerZone );	// by sigi
	for (uint i = 0 ; i < m_MonsterCount ; i++)
		msg << ",Monster[" << i << "] : " << (int)m_MonsterTypes[i];

	msg << ",Width:"  << (int)m_Width
		<< ",Height:" << (int)m_Height
		<< ")";

	return msg.toString();

	__END_CATCH
}

//////////////////////////////////////////////////////////////////////////////
// pTargetCreture를 볼 수 있는 자(player)들의 list를 돌려준다.
// **********************************
//////////////////////////////////////////////////////////////////////////////
list<Creature*> Zone::getWatcherList(ZoneCoord_t x, ZoneCoord_t y, Creature* pTargetCreature)
	throw (Error)
{
	__BEGIN_TRY

	list<Creature*> cList;

	////////////////////////////////////////////////////////////
	// 시야 영역의 상하좌우 모두 + 1 씩 증가시킨다. 
	// 이유는 방향에 따른 ON_SIGHT 영역이 증가되기 때문이다.
	////////////////////////////////////////////////////////////
	for (ZoneCoord_t ix = max(0, x - maxViewportWidth - 1), endx = min(m_Width - 1, x + maxViewportWidth + 1) ; ix <= endx ; ix++) 
	{
		for (ZoneCoord_t iy = max(0, y - maxViewportUpperHeight - 1), endy = min(m_Height - 1, y + maxViewportLowerHeight + 1) ; iy <= endy ; iy++) 
		{
			const slist<Object*> & objectList = m_pTiles[ix][iy].getObjectList();
			slist<Object*>::const_iterator itr = objectList.begin();
			for (; itr != objectList.end() && (*itr)->getObjectPriority() <= OBJECT_PRIORITY_BURROWING_CREATURE; itr++) 
			{
				Assert(*itr != NULL);

				Creature* pCreature = dynamic_cast<Creature*>(*itr);

				Assert(pCreature != NULL);

				if (pCreature->isPC()) 
				{
					Assert(pCreature->getPlayer() != NULL);

					// 자기 자신의 정보는 받을 필요가 없다.
					if (pTargetCreature == pCreature) continue;
				
					VisionState vs = pCreature->getVisionState(x,y);

					if (vs >= IN_SIGHT)
					{
						// Revealer 이펙트를 가져온다.
//						EffectRevealer* pEffectRevealer = NULL;
//						if ( pCreature->isFlag( Effect::EFFECT_CLASS_REVEALER ) )
//						{
//							pEffectRevealer = dynamic_cast<EffectRevealer*>(pCreature->findEffect(Effect::EFFECT_CLASS_REVEALER));
//							Assert( pEffectRevealer );
//						}

						if (pCreature->getCreatureClass() == Creature::CREATURE_CLASS_SLAYER)
						{
							// 여기 밑에도 &&가 아니라 ||가 아닐까? /by elca
							if (pTargetCreature == NULL 
								|| 	((!pTargetCreature->isFlag(Effect::EFFECT_CLASS_HIDE) || pCreature->isFlag(Effect::EFFECT_CLASS_DETECT_HIDDEN) )// || ( pEffectRevealer != NULL && pEffectRevealer->canSeeHide( pTargetCreature ) ) )
									&& (!pTargetCreature->isFlag(Effect::EFFECT_CLASS_INVISIBILITY) || pCreature->isFlag(Effect::EFFECT_CLASS_DETECT_INVISIBILITY) ) //|| ( pEffectRevealer != NULL && pEffectRevealer->canSeeInvisibility( pTargetCreature ) ) )
									&& (!pTargetCreature->isFlag(Effect::EFFECT_CLASS_SNIPING_MODE) || pCreature->isFlag(Effect::EFFECT_CLASS_DETECT_INVISIBILITY) ))// || ( pEffectRevealer != NULL && pEffectRevealer->canSeeSniping( pTargetCreature ) ) ))
								)

							{
								cList.push_back(pCreature);
							}
						}
						else if (pCreature->getCreatureClass() == Creature::CREATURE_CLASS_VAMPIRE)
						{
							// 뱀파이어도 이제 상대가 스나이핑 상태라면 못본다.
							if (pTargetCreature == NULL || !pTargetCreature->isSlayer() || !pTargetCreature->isFlag(Effect::EFFECT_CLASS_SNIPING_MODE) )// || ( pEffectRevealer != NULL && pEffectRevealer->canSeeSniping( pTargetCreature ) ) )
							{
								cList.push_back(pCreature);
							}
						}
						else
						{
							Assert(false);
						}
					}
				}//if

			}//for

		}//for

	}//for


	return cList;
	
	__END_CATCH
}

void Zone::addToItemList(Item* pItem) throw()
{
	__BEGIN_TRY

	m_Items[ pItem->getObjectID()] = pItem;

	__END_CATCH
}

void Zone::deleteFromItemList(ObjectID_t id) throw()
{
	__BEGIN_TRY

	hash_map< ObjectID_t, Item*>::iterator itr = m_Items.find(id);

	if (itr == m_Items.end())
		//throw NoSuchElementException();
		// NoSuch제거. by sigi. 2002.5.3
	{
		return;
	}

	m_Items.erase(itr);

	__END_CATCH
}

void Zone::addVampirePortal(ZoneCoord_t cx, ZoneCoord_t cy, Vampire* pVampire, const ZONE_COORD& ZoneCoord) 
	throw()
{
	__BEGIN_TRY

	Assert(m_OuterRect.ptInRect(cx, cy));
	Assert(pVampire != NULL);

	// 뱀파이어의 능력에 따라 들어갈 수 있는 인원과, 지속 시간을 계산한다.
	// 존에 바로 추가되는 것이 아니므로, 약간의 딜레이를 추가해준다.
	Duration_t duration = (60 + (pVampire->getINT(ATTR_CURRENT)-20)/3) * 10 + 20; // 0.1초 단위기 때문에...
	int        count    = 3 + (pVampire->getINT(ATTR_CURRENT)-20)/10;

	// 일단 이펙트 객체 자체를 생성한다.
	EffectVampirePortal* pEffectVampirePortal = new EffectVampirePortal(this, cx, cy);
	pEffectVampirePortal->setDeadline(duration);
	pEffectVampirePortal->setOwnerID(pVampire->getName());
	pEffectVampirePortal->setZoneCoord(ZoneCoord.id, ZoneCoord.x, ZoneCoord.y);
	pEffectVampirePortal->setCount(count);

	// 이펙트 스케쥴을 생성해서 더한다.
	EffectSchedule* pEffectSchedule = new EffectSchedule;
	pEffectSchedule->setEffect(pEffectVampirePortal);
	pEffectSchedule->addWork(WORKCODE_ADD_VAMPIRE_PORTAL, NULL);
	m_pEffectScheduleManager->addEffectSchedule(pEffectSchedule);

	__END_CATCH
}

//-------------------------------------------------------------
// deleteMotorcycle( x, y, pMotorcycle )
//-------------------------------------------------------------
// 바로 지우지 않고.. zone의 heartbeat할때 지우도록
// EffectDecayItem을 붙여둔다.
//-------------------------------------------------------------
void Zone::deleteMotorcycle(ZoneCoord_t cx, ZoneCoord_t cy, Motorcycle* pMotorcycle)
	throw(Error)
{
	__BEGIN_TRY

	Assert(m_OuterRect.ptInRect(cx, cy));
	Assert(pMotorcycle != NULL);

	EffectDecayItem* pEffectDecayItem = new EffectDecayItem(this, cx, cy, (Item*)pMotorcycle, 0, 
															false); // DB에서는 지우지 않는다.
	pEffectDecayItem->setNextTime(999999);
	m_ObjectRegistry.registerObject(pEffectDecayItem);
	addEffect_LOCKING(pEffectDecayItem);
	
	__END_CATCH
}

/*
void Zone::decayMotorcycle(ZoneCoord_t cx, ZoneCoord_t cy, Motorcycle* pMotorcycle, Slayer* pSlayer)
	throw()
{
	__BEGIN_TRY

	cout << "Zone::decayMotorcycle	" << endl;

	Assert(m_OuterRect.ptInRect(cx, cy));
	Assert(pMotorcycle != NULL);

	// 존에서 오토바이를 지우는 이펙트를 추가한다.
	EffectDecayMotorcycle* pEffectDecayMotorcycle = new EffectDecayMotorcycle(this, cx, cy, (Item*)pMotorcycle, 0, 
															      false); // DB에서는 지우지 않는다.
	pEffectDecayMotorcycle->setNextTime(999999);
	m_ObjectRegistry.registerObject(pEffectDecayMotorcycle);
	addEffect_LOCKING(pEffectDecayMotorcycle);
	
	__END_CATCH
}
*/

//-------------------------------------------------------------
// transportItem
//-------------------------------------------------------------
// 현재 존의 pItem을 pZone의 (cx, cy)로 옮긴다.
// EffectTransportItem을 붙여서 옮긴다.
//-------------------------------------------------------------
void Zone::transportItem(ZoneCoord_t x, ZoneCoord_t y, Item* pItem, 
						Zone* pZone, ZoneCoord_t cx, ZoneCoord_t cy)
	throw(Error)
{
	__BEGIN_TRY

	cout << "transportItem : " << (int)pZone->getZoneID() << ", (" << cx << ", " << cy << ")" << endl;

	Assert(m_OuterRect.ptInRect(cx, cy));
	Assert(pItem != NULL);

	if (pZone==this)
	{
		// 같은 zone이면 바로 옮긴다.
		deleteFromItemList(pItem->getObjectID());
		getTile(x, y).deleteItem();

		// 아이템이 사라졌다는 패킷을 날린다.
		GCDeleteObject gcDeleteObject;
		gcDeleteObject.setObjectID(pItem->getObjectID());

		broadcastPacket(x, y , &gcDeleteObject);

		addItem(pItem, cx, cy);
	}
	else
	{
		EffectTransportItem* pEffectTransportItem = new EffectTransportItem(this, x, y, pZone, cx, cy, pItem, 0);
		pEffectTransportItem->setNextTime(999999);
		m_ObjectRegistry.registerObject(pEffectTransportItem);
		addEffect_LOCKING(pEffectTransportItem);
	}
	
	__END_CATCH
}

//-------------------------------------------------------------
// add Item Delayed
//-------------------------------------------------------------
// 아이템을 추가하는데.. 다른 thread에서 해도 된다.
// 다른 heartbeat에서 추가된다.
//-------------------------------------------------------------
void Zone::addItemDelayed(Item* pItem, ZoneCoord_t cx, ZoneCoord_t cy, bool bAllowCreature)
	throw(Error)
{
	__BEGIN_TRY

	Assert(m_OuterRect.ptInRect(cx, cy));
	Assert(pItem != NULL);

	EffectAddItem* pEffectAddItem = new EffectAddItem(this, cx, cy, pItem, 0, bAllowCreature);
	pEffectAddItem->setNextTime(999999);
	m_ObjectRegistry.registerObject(pEffectAddItem);
	addEffect_LOCKING(pEffectAddItem);
	
	__END_CATCH
}

void Zone::deleteItemDelayed(Object* pObject, ZoneCoord_t x, ZoneCoord_t y)
	throw(Error)
{
	__BEGIN_TRY
	
	Assert(m_OuterRect.ptInRect(x, y));

	EffectDeleteItem* pEffectDeleteItem = new EffectDeleteItem(this, x, y, pObject, 0);
	pEffectDeleteItem->setNextTime(999999);
	m_ObjectRegistry.registerObject(pEffectDeleteItem);
	addEffect_LOCKING(pEffectDeleteItem);

	__END_CATCH
}
//-------------------------------------------------------------
// create MonsterAddPacket
//-------------------------------------------------------------
// monster의 상태에 따라서 GCAddXXX packet을 생성한다. by sigi
//-------------------------------------------------------------
Packet* Zone::createMonsterAddPacket(Monster* pMonster, Creature* pPC) const
	throw()
{
	Assert( pMonster != NULL );

	// 보는 사람이 설정되지 않은 경우
	// 다~ 볼 수 있는 상태라고 설정한다.
	// 일단 packet을 생성해두고 체크하기 위해서다.
	bool canSeeAll = (pPC==NULL);

	// Revealer 이펙트를 가져온다.
//	EffectRevealer* pEffectRevealer = NULL;
//	if ( pPC != NULL && pPC->isFlag( Effect::EFFECT_CLASS_REVEALER ) )
//	{
//		pEffectRevealer = dynamic_cast<EffectRevealer*>(pPC->findEffect( Effect::EFFECT_CLASS_REVEALER ) );
//		Assert( pEffectRevealer );
//	}

	if (pMonster->isFlag(Effect::EFFECT_CLASS_HIDE)) 
	{
		// 뱀파거나 볼 수 있다면..
		if (canSeeAll 
			|| pPC->isVampire() 
			|| pPC->isFlag(Effect::EFFECT_CLASS_DETECT_HIDDEN) )
//			|| ( pEffectRevealer != NULL && pEffectRevealer->canSeeHide( pMonster ) ) ) 	
		{
			GCAddBurrowingCreature* pPacket = new GCAddBurrowingCreature();

			pPacket->setObjectID(pMonster->getObjectID());
			pPacket->setName(pMonster->getName());
			pPacket->setX(pMonster->getX());
			pPacket->setY(pMonster->getY());

			return pPacket;
		}

	} 
	// 박쥐인 상태
	else if (pMonster->isFlag(Effect::EFFECT_CLASS_TRANSFORM_TO_BAT))
	{
		GCAddBat* pPacket = new GCAddBat();
		pPacket->setObjectID(pMonster->getObjectID());
		pPacket->setName(pMonster->getName());
		pPacket->setXYDir(pMonster->getX(), pMonster->getY(), pMonster->getDir());
		pPacket->setItemType( 0 );	// 아직 안 쓴다.
		pPacket->setMaxHP( pMonster->getHP(ATTR_MAX) );
		pPacket->setCurrentHP( pMonster->getHP(ATTR_CURRENT) );
		pPacket->setGuildID( 1 );

		return pPacket;
	} 
	// 늑대인 상태
	else if (pMonster->isFlag(Effect::EFFECT_CLASS_TRANSFORM_TO_WOLF))
	{
		GCAddWolf* pPacket = new GCAddWolf();
		pPacket->setObjectID(pMonster->getObjectID());
		pPacket->setName(pMonster->getName());
		pPacket->setXYDir(pMonster->getX(), pMonster->getY(), pMonster->getDir());
		pPacket->setItemType( 0 );	// 아직 안 쓴다.
		pPacket->setMaxHP( pMonster->getHP(ATTR_MAX) );
		pPacket->setCurrentHP( pMonster->getHP(ATTR_CURRENT) );
		pPacket->setGuildID( 1 );

		return pPacket;
	}
	// invisiblity 상태
	else if (pMonster->isFlag(Effect::EFFECT_CLASS_INVISIBILITY))
	{
		// 보이나? 뱀파거나 볼수 있다면..
		if (canSeeAll 
			|| pPC->isVampire() 
			|| pPC->isFlag(Effect::EFFECT_CLASS_DETECT_INVISIBILITY) )
//			|| ( pEffectRevealer != NULL && pEffectRevealer->canSeeInvisibility( pMonster ) ) )
		{
			// FIXME
			// 설정에따라서 어떻게 보일지 결정된 후..
			GCAddMonster* pPacket = new GCAddMonster();
			makeGCAddMonster(pPacket, pMonster);
			pPacket->setEffectInfo(pMonster->getEffectInfo());

			return pPacket;
		}
	}
	else
	{
		GCAddMonster* pPacket = new GCAddMonster();
		makeGCAddMonster(pPacket, pMonster);

		return pPacket;
	}

	return NULL;
}

list<NPCInfo*>* Zone::getNPCInfos(void)
{ 
	return &m_NPCInfos; 
}

void Zone::addNPCInfo(NPCInfo* pInfo) 
{ 
	// 이거 zone delete할때 지워야된데이.. - -;	by sigi
	m_NPCInfos.push_back(pInfo); 
}

const BPOINT& Zone::getRandomMonsterRegenPosition() const
{
	return m_MonsterRegenPositions[rand() % m_MonsterRegenPositions.size()];
}

